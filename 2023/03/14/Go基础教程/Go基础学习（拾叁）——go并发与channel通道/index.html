
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Go基础学习（拾叁）——go并发与channel通道 | 小C♥天天</title>
        <meta name="author" content="小C&天天">
        <meta name="description" content="^v^">
        <meta name="keywords" content="">
        <link rel="icon" href="/images/icon.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <link rel="stylesheet" href="/css/main.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
        <script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>
        <link rel="stylesheet" href="/css/style.css">
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:30vmin;height:30vmin;padding:60px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #dd20dd;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">正在加载</p><div><img alt="loading" src="/images/afde9fa65a5742a90b51d6e1211e841e.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <form class="search">
            <input type="text" placeholder="需要搜索什么？">
            <button type="submit"></button>
        </form>
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        

<div id="home-posts-wrap" class=>
<div class="article">
    <div>
        <h1>Go基础学习（拾叁）——go并发与channel通道 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/3/14
        </span>
        
        <span class="category">
            <a href="/categories/Go基础教程">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                Go基础教程
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/开发" style="color: #ffa2c4">
                    开发
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Golang" style="color: #00bcd4">
                    Golang
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h1 id="壹-基本概念"><a href="#壹-基本概念" class="headerlink" title="壹 基本概念"></a>壹 基本概念</h1><p>并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，我们无一例外的想让我们的程序运行的快一点、再快一点。Go语言在语言层面天生支持并发，充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。</p>
<span id="more"></span>
<p>首先我们先来了解几个与并发编程相关的基本概念。</p>
<ul>
<li>串行、并发与并行</li>
</ul>
<p><strong>串行</strong>：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。<br><strong>并发</strong>：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。<br><strong>并行</strong>：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p>
<p><font color="red">说白了，串行就是说只有一个人当前只做一件事，并行就是当前多个人分别做多件事情，并发就是当前一个人做多件事，这里的多件事并不表示同时刻进行，可能现在走这就是，一会做另一件事，但是这期间比较短，可以看作是同时做了多件事</font>。</p>
<ul>
<li><p>进程、线程和协程</p>
</li>
<li><p>进程、线程和协程</p>
</li>
</ul>
<p><strong>进程</strong>（process）：具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。<br><strong>线程</strong>（thread）：进程内的一个执行单元，也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<br><strong>协程</strong>（coroutine）：一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，协程就是你可以暂停执行的函数。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<blockquote>
<p>线程与进程的区别：</p>
<ul>
<li>地址空间：线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li>
<li>资源拥有：进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li>
<li>线程是处理器调度的基本单位，但进程不是</li>
<li>二者均可并发执行</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li>
</ul>
</blockquote>
<blockquote>
<p>协程与线程的区别：</p>
<ul>
<li>一个线程可以多个协程，一个进程也可以单独拥有多个协程</li>
<li>线程进程都是同步机制，而协程则是异步</li>
<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>
<li>线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力</li>
<li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.</li>
<li>线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</li>
</ul>
</blockquote>
<p>个人理解：进程就可以理解为开了一个应用程序，而线程就是为了在同一时间实现应用程序的多种功能，属于是在进程的基础上实现的。而协程就是可以在进程基础上，或者线程基础上多出来的！<font color="red">注意：（进程、线程和协程）与（串行、并发和并行）不是一个维度的概念！</font></p>
<ul>
<li>并发模型</li>
</ul>
<p>业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：</p>
<ul>
<li>线程&amp;锁模型</li>
<li>Actor模型</li>
<li>CSP模型</li>
<li>Fork&amp;Join模型</li>
</ul>
<p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p>
<h1 id="贰-goroutine"><a href="#贰-goroutine" class="headerlink" title="贰 goroutine"></a>贰 goroutine</h1><h2 id="2-1-goroutine介绍"><a href="#2-1-goroutine介绍" class="headerlink" title="2.1 goroutine介绍"></a>2.1 goroutine介绍</h2><p>Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。</p>
<p><font color="red">Goroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。</font></p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。</p>
<h2 id="2-2-go关键字"><a href="#2-2-go关键字" class="headerlink" title="2.2 go关键字"></a>2.2 go关键字</h2><p>Go语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上<code>go</code>关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。</p>
<pre><code class="go">go f() // 创建一个新的 goroutine 运行函数f
</code></pre>
<p>匿名函数也支持使用<code>go</code>关键字创建 goroutine 去执行。</p>
<pre><code class="go">go func()&#123;
  // ...
&#125;()
</code></pre>
<p>一个 goroutine 必定对应一个函数&#x2F;方法，可以创建多个 goroutine 去执行相同的函数&#x2F;方法。</p>
<h2 id="2-3-启动单个goroutine"><a href="#2-3-启动单个goroutine" class="headerlink" title="2.3 启动单个goroutine"></a>2.3 启动单个goroutine</h2><p>启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个<code>go</code>关键字。</p>
<p>我们先来看一个在 main 函数中执行普通函数调用的示例。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func hello() &#123;
    fmt.Println(&quot;hello&quot;)
&#125;

func main() &#123;
    hello()
    fmt.Println(&quot;你好&quot;)
    // hello
    // 你好
&#125;
</code></pre>
<p>代码中 hello 函数和其后面的打印语句是串行的。</p>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/0d9da178ecd703c9cdbd27e0f8984bac.png" alt="0d9da178ecd703c9cdbd27e0f8984bac.png"></p>
<p>接下来我们在调用 hello 函数前面加上关键字<code>go</code>，也就是启动一个 goroutine 去执行 hello 这个函数。</p>
<pre><code class="go">func hello() &#123;
    fmt.Println(&quot;hello&quot;)
&#125;
func main() &#123;
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println(&quot;main goroutine done!&quot;)
&#125;
// 你好
</code></pre>
<p>这一次的执行结果只在终端打印了你好，并没有打印 <code>hello</code>。这是为什么呢？</p>
<p>其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine，也就是main goroutine。在上面的代码中我们在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，这里我们叫它hello goroutine，这中间需要消耗一些时间，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出hello。</p>
<p>所以我们要想办法让 main 函数等一等另一个 goroutine 中运行的 hello 函数。其中最简单粗暴的方式就是在 main 函数中time.Sleep一秒钟了（这里的1秒钟只是我们为了保证新的 goroutine 能够被正常创建和执行而设置的一个值）。</p>
<p>按如下方式修改我们的示例代码。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func hello() &#123;
    fmt.Println(&quot;hello&quot;)
&#125;

func main() &#123;
    go hello()
    fmt.Println(&quot;你好&quot;)
    time.Sleep(time.Second)
    // 你好
    // hello
&#125;
</code></pre>
<p>为什么会先打印<code>你好</code>呢？</p>
<p>这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。</p>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/cacd05a21a61f221ab2793eff1062b21.png" alt="cacd05a21a61f221ab2793eff1062b21.png"></p>
<p>在上面的程序中使用<code>time.Sleep</code>让 main goroutine 等待 hello goroutine执行结束是不优雅的，当然也是不准确的。</p>
<p>Go 语言中通过<code>sync</code>包为我们提供了一些常用的并发方法。首先我们介绍一下<code>sync</code>包中的<code>WaitGroup</code>。<font color="red">当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，<code>WaitGroup</code>是实现等待一组并发操作完成的好方法</font>。</p>
<p>下面的示例代码中我们在 main goroutine 中使用<code>sync.WaitGroup</code>来等待 hello goroutine 完成后再退出。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)
// 声明全局等待组变量
var wg sync.WaitGroup

func hello() &#123;
    fmt.Println(&quot;hello&quot;)
    wg.Done() // 告知当前goroutine完成
&#125;

func main() &#123;
    wg.Add(1) // 登记1个goroutine
    go hello()
    fmt.Println(&quot;你好&quot;)
    wg.Wait() // 阻塞等待登记的goroutine完成
&#125;
</code></pre>
<p>将代码编译后再执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。</p>
<p><font color="red">在这里需要说明，这里启动的是 goroutine 个数是根据<code>wf.Add</code>的传入的参数决定的。</font></p>
<h2 id="2-4-启动多个goroutine"><a href="#2-4-启动多个goroutine" class="headerlink" title="2.4 启动多个goroutine"></a>2.4 启动多个goroutine</h2><p>在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。如果要实现多个呢？现在介绍两种方法：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var wg sync.WaitGroup

func hello(i int) &#123;
    defer wg.Done() // goroutine结束就登记-1
    fmt.Println(&quot;hello&quot;, i)
&#125;
func main() &#123;
    // 第一种是将要启动的goroutine总数事先声明
    wg.Add(10) // 事先定义10个goroutine
    for i := 0; i &lt; 10; i++ &#123;

        go hello(i)
    &#125;
    wg.Wait() // 等待所有登记的goroutine都结束
    fmt.Println(&quot;----------分割线-----------&quot;)
    // 第二种是再循环里启动goroutine，每次+1，这种方法个人不建议使用，会因为程序的条件竞争导致wg里面的goroutine多执行一次wg.Done
    for i := 0; i &lt; 10; i++ &#123;
        wg.Add(1) // 事先定义10个goroutine
        go hello(i)
    &#125;
    wg.Wait() // 等待所有登记的goroutine都结束
&#125;
</code></pre>
<p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。</p>
<h2 id="2-5-一些理论概念"><a href="#2-5-一些理论概念" class="headerlink" title="2.5 一些理论概念"></a>2.5 一些理论概念</h2><ul>
<li><p>动态栈<br>操作系统的线程一般都有固定的栈内存（通常为2MB），而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p>
</li>
<li><p>GOMAXPROCS<br>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过<code>runtime.GOMAXPROCS</code>函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）</p>
</li>
</ul>
<h2 id="2-6-goroutine调度"><a href="#2-6-goroutine调度" class="headerlink" title="2.6 goroutine调度"></a>2.6 goroutine调度</h2><p>操作系统的线程会被操作系统内核调度时会挂起当前执行的线程并将它的寄存器内容保存到内存中，选出下一次要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p>
<p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p>
<p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/630a9e8580a2912606cebec3a5082015.png" alt="630a9e8580a2912606cebec3a5082015.png"></p>
<p>其中：</p>
<ul>
<li>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</li>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
<li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li>
</ul>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p>
<ul>
<li>小插曲：</li>
</ul>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    for i := 0; i &lt; 5; i++ &#123;
        go func() &#123;
            fmt.Println(i)
        &#125;()
    &#125;
    time.Sleep(1)
&#125;
// 在运行完这一段代码时，会输出值5，偶尔出现其他值，个人认为原因可能是匿名函数每一次运行都会清空，当要输出时，下一个循环就将其覆盖，导致最后只剩下一个赋值为5
</code></pre>
<h1 id="叁-channel——通道类型"><a href="#叁-channel——通道类型" class="headerlink" title="叁 channel——通道类型"></a>叁 channel——通道类型</h1><h2 id="2-1-channel类型"><a href="#2-1-channel类型" class="headerlink" title="2.1 channel类型"></a>2.1 channel类型</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。就例如我们需要将并发中的值返回，但是<code>goroutine</code>是不存在值返回的，当然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<font color="red">通过通信共享内存</font>而不是<font color="red">通过共享内存而实现通信</font>。</p>
<p><font color="red">如果说 goroutine 是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</font></p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是<font color="red">遵循先入先出（First In First Out）的规则</font>，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。声明通道类型变量的格式如下：</p>
<pre><code class="go">var 变量名称 chan 元素类型
// chan：是关键字
// 元素类型：是指通道中传递元素的类型
</code></pre>
<p>举几个例子：</p>
<pre><code class="go">var ch1 chan int   // 声明一个传递整型的通道
var ch2 chan bool  // 声明一个传递布尔型的通道
var ch3 chan []int // 声明一个传递int切片的通道
</code></pre>
<h2 id="2-2-channel零值"><a href="#2-2-channel零值" class="headerlink" title="2.2 channel零值"></a>2.2 channel零值</h2><p>未初始化的通道类型变量其默认零值是<code>nil</code>。</p>
<pre><code class="go">var ch chan int
fmt.Println(ch) // &lt;nil&gt;
</code></pre>
<h2 id="2-3-初始化channel"><a href="#2-3-初始化channel" class="headerlink" title="2.3 初始化channel"></a>2.3 初始化channel</h2><p>声明的通道类型变量需要使用内置的<code>make</code>函数初始化之后才能使用。具体格式如下：</p>
<pre><code class="go">make(chan 元素类型, [缓冲大小])
// channel的缓冲大小是可选的。
</code></pre>
<p>举几个例子：</p>
<pre><code class="go">ch4 := make(chan int)
ch5 := make(chan bool, 1)  // 声明一个缓冲区大小为1的通道
</code></pre>
<h2 id="2-4-channel操作"><a href="#2-4-channel操作" class="headerlink" title="2.4 channel操作"></a>2.4 channel操作</h2><p>通道共有发送（send）、接收(receive）和关闭（close）三种操作。而发送和接收操作都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<pre><code class="go">ch := make(chan int)
</code></pre>
<ul>
<li><strong>发送</strong></li>
</ul>
<p>将一个值发送到通道中。</p>
<pre><code class="go">ch &lt;- 10 // 把10发送到ch中
</code></pre>
<ul>
<li><strong>接收</strong></li>
</ul>
<p>从一个通道中接收值。</p>
<pre><code class="go">x := &lt;- ch // 从ch中接收值并赋值给变量x
&lt;-ch       // 从ch中接收值，忽略结果
</code></pre>
<ul>
<li><strong>关闭</strong></li>
</ul>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<pre><code class="go">close(ch)
</code></pre>
<p><font color="red">注意：一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</font></p>
<p>关闭后的通道有以下特点：</p>
<ul>
<li>a.对一个关闭的通道再发送值就会导致 panic。</li>
<li>b.对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>c.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>d.关闭一个已经关闭的通道会导致 panic。</li>
</ul>
<h2 id="2-5-无缓冲的通道"><a href="#2-5-无缓冲的通道" class="headerlink" title="2.5 无缓冲的通道"></a>2.5 无缓冲的通道</h2><p>无缓冲的通道又称为阻塞的通道。我们来看一下如下代码片段。</p>
<pre><code class="go">func main() &#123;
    ch := make(chan int)
    ch &lt;- 10
    fmt.Println(&quot;发送成功&quot;)
&#125;
</code></pre>
<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<pre><code class="bash">fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        .../main.go:8 +0x54
</code></pre>
<p><code>deadlock</code>表示我们程序中的 goroutine 都被挂起导致程序死锁了。为什么会出现<code>deadlock</code>错误呢？</p>
<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。就像田径比赛中的4x100接力赛，想要完成交棒必须有一个能够接棒的运动员，否则只能等待。简单来说就是无缓冲的通道必须有至少一个接收方才能发送成功。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>其中一种可行的方法是创建一个 goroutine 去接收值，例如：</p>
<pre><code class="go">func recv(c chan int) &#123;
    ret := &lt;-c
    fmt.Println(&quot;接收成功&quot;, ret)
&#125;

func main() &#123;
    ch := make(chan int)
    go recv(ch) // 创建一个 goroutine 从通道接收值
    ch &lt;- 10
    fmt.Println(&quot;发送成功&quot;)
&#125;
</code></pre>
<p>首先无缓冲通道<code>ch</code>上的发送操作会阻塞，直到另一个 goroutine 在该通道上执行接收操作，这时数字10才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方所在的 goroutine 将阻塞，直到 main goroutine 中向该通道发送数字10。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h2 id="2-6-有缓冲的通道"><a href="#2-6-有缓冲的通道" class="headerlink" title="2.6 有缓冲的通道"></a>2.6 有缓冲的通道</h2><p>还有另外一种解决上面死锁问题的方法，那就是使用有缓冲区的通道。我们可以在使用 make 函数初始化通道时，可以为其指定通道的容量，例如：</p>
<pre><code class="go">func main() &#123;
    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
    ch &lt;- 10
    fmt.Println(&quot;发送成功&quot;)
&#125;
</code></pre>
<p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
<h2 id="2-7-多返回值模式"><a href="#2-7-多返回值模式" class="headerlink" title="2.7 多返回值模式"></a>2.7 多返回值模式</h2><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？</p>
<p>对一个通道执行接收操作时支持使用如下多返回值模式。</p>
<pre><code class="go">value, ok := &lt;- ch
// value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。
// ok：通道ch关闭时返回 false，否则返回 true。
</code></pre>
<p>下面代码片段中的<code>f2</code>函数会循环从通道<code>ch</code>中接收所有值，直到通道被关闭后退出。</p>
<pre><code class="go">func f2(ch chan int) &#123;
    for &#123;
        v, ok := &lt;-ch
        if !ok &#123;
            fmt.Println(&quot;通道已关闭&quot;)
            break
        &#125;
        fmt.Printf(&quot;v:%#v ok:%#v\n&quot;, v, ok)
    &#125;
&#125;

func main() &#123;
    ch := make(chan int, 1)
    ch &lt;- 1
  ch &lt;- 2
    close(ch)
    f2(ch)
&#125;
</code></pre>
<h2 id="2-8-for-range接收值"><a href="#2-8-for-range接收值" class="headerlink" title="2.8 for range接收值"></a>2.8 for range接收值</h2><p>通常我们会选择使用<code>for range</code>循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用<code>for range</code>改写后会很简洁。</p>
<pre><code class="go">func f3(ch chan int) &#123;
    for v := range ch &#123;
        fmt.Println(v)
    &#125;
&#125;
</code></pre>
<p><font color="red">注意：目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过<code>len(ch)</code>操作来判断通道是否被关闭。</font></p>
<h2 id="2-9-单向通道"><a href="#2-9-单向通道" class="headerlink" title="2.9 单向通道"></a>2.9 单向通道</h2><p>在某些场景下我们可能会将通道作为参数在多个任务函数间进行传递，通常我们会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。想象一下，我们现在有<code>Producer</code>和<code>Consumer</code>两个函数，其中<code>Producer</code>函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而<code>Consumer</code>函数的任务是从通道中接收值进行计算，这两个函数之间通过<code>Processer</code>函数返回的通道进行通信。完整的示例代码如下。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

// Producer 返回一个通道
// 并持续将符合条件的数据发送至返回的通道中
// 数据发送完成后会将返回的通道关闭
func Producer() chan int &#123;
    ch := make(chan int, 2)
    // 创建一个新的goroutine执行发送数据的任务
    go func() &#123;
        for i := 0; i &lt; 10; i++ &#123;
            if i%2 == 1 &#123;
                ch &lt;- i
            &#125;
        &#125;
        close(ch) // 任务完成后关闭通道
    &#125;()

    return ch
&#125;

// Consumer 从通道中接收数据进行计算
func Consumer(ch chan int) int &#123;
    sum := 0
    for v := range ch &#123;
        sum += v
    &#125;
    return sum
&#125;

func main() &#123;
    ch := Producer()

    res := Consumer(ch)
    fmt.Println(res) // 25
&#125;
</code></pre>
<p>从上面的示例代码中可以看出正常情况下<code>Consumer</code>函数中只会对通道进行接收操作，但是这不代表不可以在<code>Consumer</code>函数中对通道进行发送操作。作为<code>Producer</code>函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在<code>Consumer</code>函数中对通道进行发送操作。Go语言中提供了<font color="red">单向通道</font>来处理这种需要限制通道只能进行某种操作的情况。</p>
<ul>
<li>格式：<pre><code class="go">&lt;-chan int // 只接收通道，只能接收不能发送
chan &lt;- int // 只发送通道，只能发送不能接收
</code></pre>
</li>
</ul>
<p>其中，箭头<code>&lt;-</code>和关键字<code>chan</code>的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</p>
<p>我们使用单向通道将上面的示例代码进行如下改造。</p>
<pre><code class="go">// Producer2 返回一个接收通道
func Producer2() &lt;-chan int &#123;
    ch := make(chan int, 2)
    // 创建一个新的goroutine执行发送数据的任务
    go func() &#123;
        for i := 0; i &lt; 10; i++ &#123;
            if i%2 == 1 &#123;
                ch &lt;- i
            &#125;
        &#125;
        close(ch) // 任务完成后关闭通道
    &#125;()

    return ch
&#125;

// Consumer2 参数为接收通道
func Consumer2(ch &lt;-chan int) int &#123;
    sum := 0
    for v := range ch &#123;
        sum += v
    &#125;
    return sum
&#125;

func main() &#123;
    ch2 := Producer2()

    res2 := Consumer2(ch2)
    fmt.Println(res2) // 25
&#125;
</code></pre>
<p>这一次，<code>Producer</code>函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。<font color="red">可能会觉着这样的限制是多余的，但是试想一下如果<code>Producer</code>函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</font></p>
<p>在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</p>
<pre><code class="go">var ch3 = make(chan int, 1)
ch3 &lt;- 10
close(ch3)
Consumer2(ch3) // 函数传参时将ch3转为单向通道

var ch4 = make(chan int, 1)
ch4 &lt;- 10
var ch5 &lt;-chan int // 声明一个只接收通道ch5
ch5 = ch4          // 变量赋值时将ch4转为单向通道
&lt;-ch5
</code></pre>
<h2 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h2><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。</p>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/9fc02f6931988e6a49eef6dd24b2f88e.png" alt="9fc02f6931988e6a49eef6dd24b2f88e.png"></p>
<p><font color="red">注意：对已经关闭的通道再执行 close 也会引发 panic。</font>这里有一篇文章介绍：<a target="_blank" rel="noopener" href="http://m.biancheng.net/view/104.html">关闭通道后继续使用通道出现的问题</a></p>
<ul>
<li>给被关闭通道发送数据将会触发 panic</li>
<li>从已关闭的通道接收数据时将不会发生阻塞</li>
</ul>
<h2 id="2-11-select多路复用"><a href="#2-11-select多路复用" class="headerlink" title="2.11 select多路复用"></a>2.11 select多路复用</h2><p>在某些场景下我们可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 <code>goroutine</code>将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。</p>
<pre><code class="go">for&#123;
    // 尝试从ch1接收值
    data, ok := &lt;-ch1
    // 尝试从ch2接收值
    data, ok := &lt;-ch2
    …
&#125;
</code></pre>
<p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了<code>select</code>关键字，使用它可以同时响应多个通道的操作。</p>
<p><code>Select</code> 的使用方式类似于之前学到的 <code>switch</code> 语句，它也有一系列 <code>case</code> 分支和一个默认的分支。每个 <code>case</code> 分支会对应一个通道的通信（接收或发送）过程。<code>select</code> 会一直等待，直到其中的某个 <code>case</code> 的通信操作完成时，就会执行该 <code>case</code> 分支对应的语句。</p>
<ul>
<li>具体格式如下：<pre><code class="go">select &#123;
case &lt;-ch:
  //...
case data := &lt;-ch:
  // 表示将ch通道的值赋值给data
  // ...
case ch &lt;- 数值:
  // 表示将数值放到ch通道里面
  // ...
default:
  //默认操作
  // 可以看上面的格式，冒号后可以直接结束，不进行内容输入，也可以存在语句
&#125;
</code></pre>
</li>
</ul>
<p><code>Select</code> 语句具有以下特点：</p>
<ul>
<li>可处理一个或多个 <code>channel</code> 的发送&#x2F;接收操作。</li>
<li>如果多个 <code>case</code> 同时满足，<code>select</code> 会<strong>随机</strong>选择一个执行。</li>
<li>对于没有 <code>case</code> 的 <code>select</code> 会一直阻塞，可用于阻塞 <code>main</code> 函数，防止退出。</li>
</ul>
<p>下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;
    // 创建一个通道，容量为2
    ch := make(chan int, 2)
    // 循环10次
    for i := 0; i &lt;= 10; i++ &#123;
        // 使用select进行选择
        select &#123;
        case data := &lt;-ch:
            fmt.Println(data)
        case ch &lt;- i:
        &#125;
    &#125;
    data := &lt;-ch
    fmt.Println(data)
    close(ch)
    // 示例中的代码首先是创建了一个缓冲区大小为2的通道 ch，进入 for 循环后：
    // 第一次循环时 i = 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以 data := &lt;-ch 这个 case 分支不满足，而 ch &lt;- i 这个分支可以执行，会把1发送到通道中，结束本次 for 循环；
    // 第二次 for 循环时，i = 2，由于都满足，所以随机选择一个执行，假设我们执行了 data := &lt;-ch ，那么就是从通道ch接收值1并赋值给变量 data ，所以会在终端打印出 1；
    // 后续的 for 循环以此类推，输出结果不一。
&#125;
</code></pre>
<h2 id="2-12-通道误用示例"><a href="#2-12-通道误用示例" class="headerlink" title="2.12 通道误用示例"></a>2.12 通道误用示例</h2><p>接下来，我们将展示两个因误用通道导致程序出现 <code>bug</code> 的代码片段，希望能够加深读者对通道操作的印象。</p>
<ul>
<li>示例1</li>
</ul>
<p>各位读者可以查看以下示例代码，尝试找出其中存在的问题。</p>
<pre><code class="go">func main() &#123;
    wg := sync.WaitGroup&#123;&#125;

    ch := make(chan int, 10)
    for i := 0; i &lt; 10; i++ &#123;
        ch &lt;- i
    &#125;
    close(ch)

    wg.Add(3)
    for j := 0; j &lt; 3; j++ &#123;
        go func() &#123;
            for i := 0; i &lt; 20; i++ &#123;
                // 错误的操作
                task := &lt;-ch
                // 这里假设对接收的数据执行某些操作
                fmt.Println(task)
                // 该操作会一直循环20次，而不是10次

                // 正确的操作
                // task, ok := &lt;-ch
                // if !ok &#123;
                // 	break
                // &#125;
                // fmt.Println(task)
            &#125;
            wg.Done()
        &#125;()
    &#125;
    wg.Wait()
&#125;
</code></pre>
<p>将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为<code>task := &lt;- ch</code>的接收操作在通道被关闭后会一直接收到零值，而不会退出。此处的接收操作应该使用<code>task, ok := &lt;- ch</code>，通过判断布尔值<code>ok</code>为假时退出或者使用select 来处理通道。</p>
<ul>
<li>示例2</li>
</ul>
<pre><code class="go">// demo2 通道误用导致的bug
func demo2() &#123;
    ch := make(chan string)
    go func() &#123;
        // 这里假设执行一些耗时的操作
        time.Sleep(3 * time.Second)
        ch &lt;- &quot;job result&quot;
    &#125;()

    select &#123;
    case result := &lt;-ch:
        fmt.Println(result)
    case &lt;-time.After(time.Second): // 较小的超时时间
        return
    &#125;
&#125;
</code></pre>
<p>上述代码片段可能导致 <code>goroutine</code> 泄露（<code>goroutine</code> 并未按预期退出并销毁）。由于 <code>select</code> 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 <code>goroutine</code> 中的<code>ch &lt;- &quot;job result&quot;</code>操作会一直阻塞，最终导致 <code>goroutine</code> 泄露。</p>
<h1 id="肆-并发安全和锁"><a href="#肆-并发安全和锁" class="headerlink" title="肆 并发安全和锁"></a>肆 并发安全和锁</h1><p>有时候我们的代码中可能会存在多个 <code>goroutine</code> 同时操作一个资源（临界区）的情况，这种情况下就会发生<code>竞态问题</code>（数据竞态），就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。举个例子：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var (
    x int64
    wg sync.WaitGroup // 等待组
)

// add 对全局变量x执行5000次加1操作
func add() &#123;
    for i := 0; i &lt; 5000; i++ &#123;
        x = x + 1
    &#125;
    wg.Done()
&#125;

func main() &#123;
    wg.Add(2)

    go add()
    go add()

    wg.Wait()
    fmt.Println(x)
&#125;
</code></pre>
<p>我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？在上面的示例代码片中，我们开启了两个 <code>goroutine</code> 分别执行 <code>add</code> 函数，这两个 <code>goroutine</code> 在访问和修改全局的<code>x</code>变量时就会存在数据竞争，某个 <code>goroutine</code> 中对全局变量<code>x</code>的修改可能会覆盖掉另一个 <code>goroutine</code> 中的操作，所以导致最后的结果与预期不符。</p>
<h2 id="4-1-互斥锁"><a href="#4-1-互斥锁" class="headerlink" title="4.1 互斥锁"></a>4.1 互斥锁</h2><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 <code>goroutine</code> 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p>
<p><code>sync.Mutex</code>提供了两个方法供我们使用。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>func (m *Mutex) Lock()</code></td>
<td>获取互斥锁</td>
</tr>
<tr>
<td><code>func (m *Mutex) Unlock()</code></td>
<td>释放互斥锁</td>
</tr>
</tbody></table>
<p>在下面的示例代码中使用互斥锁限制每次只有一个 <code>goroutine</code> 才能修改全局变量 <code>x</code>，从而修复上面代码中的问题。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

// sync.Mutex

var (
    x int64
    wg sync.WaitGroup // 等待组
    m sync.Mutex // 互斥锁
)

// add 对全局变量x执行5000次加1操作
func add() &#123;
    for i := 0; i &lt; 5000; i++ &#123;
        m.Lock() // 修改x前加锁
        x = x + 1
        m.Unlock() // 改完解锁
    &#125;
    wg.Done()
&#125;

func main() &#123;
    wg.Add(2)

    go add()
    go add()

    wg.Wait()
    fmt.Println(x)	// 结果为：10000
&#125;
</code></pre>
<p>使用互斥锁能够保证同一时间有且只有一个 <code>goroutine</code> 进入临界区，其他的 <code>goroutine</code> 则在等待锁；当互斥锁释放后，等待的 <code>goroutine</code> 才可以获取锁进入临界区，多个 <code>goroutine</code> 同时等待一个锁时，唤醒的策略是随机的。</p>
<h2 id="4-2-读写互斥锁"><a href="#4-2-读写互斥锁" class="headerlink" title="4.2 读写互斥锁"></a>4.2 读写互斥锁</h2><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p><code>sync.RWMutex</code>提供了以下5个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>func (rw *RWMutex) Lock()</code></td>
<td>获取写锁</td>
</tr>
<tr>
<td><code>func (rw *RWMutex) Unlock()</code></td>
<td>释放写锁</td>
</tr>
<tr>
<td><code>func (rw *RWMutex) RLock()</code></td>
<td>获取读锁</td>
</tr>
<tr>
<td><code>func (rw *RWMutex) RUnlock()</code></td>
<td>释放读锁</td>
</tr>
<tr>
<td><code>func (rw *RWMutex) RLocker() Locker</code></td>
<td>返回一个实现Locker接口的读写锁</td>
</tr>
</tbody></table>
<p>读写锁分为两种：读锁和写锁。当一个 <code>goroutine</code> 获取到读锁之后，其他的 <code>goroutine</code> 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 <code>goroutine</code> 获取写锁之后，其他的 <code>goroutine</code> 无论是获取读锁还是写锁都会等待。接下来使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var (
    x       int64
    wg      sync.WaitGroup
    mutex   sync.Mutex
    rwMutex sync.RWMutex
)

// writeWithLock 使用互斥锁的写操作
func writeWithLock() &#123;
    mutex.Lock() // 加互斥锁
    x = x + 1
    time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒
    mutex.Unlock()                    // 解互斥锁
    wg.Done()
&#125;

// readWithLock 使用互斥锁的读操作
func readWithLock() &#123;
    mutex.Lock()                 // 加互斥锁
    time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒
    mutex.Unlock()               // 释放互斥锁
    wg.Done()
&#125;

// writeWithLock 使用读写互斥锁的写操作
func writeWithRWLock() &#123;
    rwMutex.Lock() // 加写锁
    x = x + 1
    time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒
    rwMutex.Unlock()                  // 释放写锁
    wg.Done()
&#125;

// readWithRWLock 使用读写互斥锁的读操作
func readWithRWLock() &#123;
    rwMutex.RLock()              // 加读锁
    time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒
    rwMutex.RUnlock()            // 释放读锁
    wg.Done()
&#125;

func do(wf, rf func(), wc, rc int) &#123;
    start := time.Now()
    // wc个并发写操作
    for i := 0; i &lt; wc; i++ &#123;
        wg.Add(1)
        go wf()
    &#125;

    //  rc个并发读操作
    for i := 0; i &lt; rc; i++ &#123;
        wg.Add(1)
        go rf()
    &#125;

    wg.Wait()
    cost := time.Since(start)
    fmt.Printf(&quot;x:%v cost:%v\n&quot;, x, cost)

&#125;

// demo1 通道误用导致的bug
func main() &#123;
    // 假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据
    // 使用互斥锁，10并发写，1000并发读
    do(writeWithLock, readWithLock, 10, 1000) // x:10 cost:15.6837087s
    // 使用读写互斥锁，10并发写，1000并发读
    do(writeWithRWLock, readWithRWLock, 10, 1000) // x:20 cost:169.8663ms
&#125;
</code></pre>
<p><font color="red">从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能，不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。</font></p>
<h2 id="4-3-sync-WaitGroup——等待组"><a href="#4-3-sync-WaitGroup——等待组" class="headerlink" title="4.3 sync.WaitGroup——等待组"></a>4.3 sync.WaitGroup——等待组</h2><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>func (wg * WaitGroup) Add(delta int)</code></td>
<td>计数器+delta</td>
</tr>
<tr>
<td><code>func (wg *WaitGroup) Done()</code></td>
<td>计数器-1</td>
</tr>
<tr>
<td><code>func (wg *WaitGroup) Wait()</code></td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p><font color="red"><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 <code>Done</code> 方法将计数器减1。通过调用 <code>Wait</code> 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。</font></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func hello(wg *sync.WaitGroup, num int) &#123;

    defer wg.Done()
    fmt.Println(&quot;Hello Goroutine!&quot;, num)
&#125;
func main() &#123;
    var wg sync.WaitGroup // 定义一个等待组
    for i := 1; i &lt; 10; i++ &#123;
        wg.Add(1)
        // 需要注意`sync.WaitGroup`是一个结构体，进行参数传递的时候要传递指针。
        go hello(&amp;wg, i) // 启动另外一个goroutine去执行hello函数
    &#125;
    fmt.Println(&quot;main goroutine done!&quot;)
    wg.Wait()
&#125;
</code></pre>
<h2 id="4-4-sync-Once——高并发下仅执行一次-amp-单例模式"><a href="#4-4-sync-Once——高并发下仅执行一次-amp-单例模式" class="headerlink" title="4.4 sync.Once——高并发下仅执行一次&amp;单例模式"></a>4.4 sync.Once——高并发下仅执行一次&amp;单例模式</h2><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<pre><code class="go">func (o *Once) Do(f func())
</code></pre>
<p><strong>注意</strong>：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。<font color="red"><code>f</code>这个函数在一个项目中无论被调用多少次，全局都只会执行一次。</font><code>once.Do</code>是不可以嵌套使用的，嵌套使用将导致死锁。</p>
<p>对于<code>sync.once</code>介绍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36310758/article/details/115326176">sync.once详解</a></p>
<h3 id="4-4-1-加载配置文件示例"><a href="#4-4-1-加载配置文件示例" class="headerlink" title="4.4.1 加载配置文件示例"></a>4.4.1 加载配置文件示例</h3><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在<code>init</code>函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。</p>
<p>我们来看一个例子：</p>
<pre><code class="go">var icons map[string]image.Image

// 创建一个loadIcons函数
func loadIcons() &#123;
    icons = map[string]image.Image&#123;
        &quot;left&quot;:  loadIcon(&quot;left.png&quot;),
        &quot;up&quot;:    loadIcon(&quot;up.png&quot;),
        &quot;right&quot;: loadIcon(&quot;right.png&quot;),
        &quot;down&quot;:  loadIcon(&quot;down.png&quot;),
    &#125;
&#125;

// Icon 被多个goroutine调用时不是并发安全的
func Icon(name string) image.Image &#123;
    // 这里这个loadIcons函数我们希望它在项目中只调用一次，所以需要判断是否为nil
    if icons == nil &#123;
        loadIcons()
    &#125;
    return icons[name]
&#125;
</code></pre>
<p>如果多个 <code>goroutine</code> 并发调用<code>Icon</code>函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 <code>goroutine</code> 都满足串行一致的基础上自由地重排访问内存的顺序。</p>
<p>在这种情况下就会出现即使判断了<code>icons</code>不是<code>nil</code>也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的 <code>goroutine</code> 操作，但是这样做又会引发性能问题。所以我们使用<code>sync.Once</code>改造该示例代码：</p>
<pre><code class="go">var icons map[string]image.Image

var loadIconsOnce sync.Once

func loadIcons() &#123;
    icons = map[string]image.Image&#123;
        &quot;left&quot;:  loadIcon(&quot;left.png&quot;),
        &quot;up&quot;:    loadIcon(&quot;up.png&quot;),
        &quot;right&quot;: loadIcon(&quot;right.png&quot;),
        &quot;down&quot;:  loadIcon(&quot;down.png&quot;),
    &#125;
&#125;

// Icon 是并发安全的
func Icon(name string) image.Image &#123;
    loadIconsOnce.Do(loadIcons)
    return icons[name]
&#125;
</code></pre>
<h3 id="4-4-2-并发安全的单例模式"><a href="#4-4-2-并发安全的单例模式" class="headerlink" title="4.4.2 并发安全的单例模式"></a>4.4.2 并发安全的单例模式</h3><p>单例是一种设计模式，实现单例的类需要保证不管外部程序如何改变，单例类只能存在唯一的实例，个人理解就是说在一个项目中，只允许一次，这就是单例，例如：数据库的初始化，加载。单例模式有两种模式：<strong>饿汉模式</strong>和<strong>懒汉模式</strong>。</p>
<p><strong>饿汉模式</strong>：是指在程序启动时就进行数据加载，这样避免了数据冲突，也是线程安全的，但是这可能会造成内存浪费。比如在程序启动时就<code>new</code>一个对象加载相关数据，当需要调用该对象相关方法时，不用再创建对象。<br><strong>懒汉模式</strong>：是指需要执行对象相关方法时，才主动去加载数据，这样做可以避免内存的浪费，比如当需要调用一个对象相关的方法时，才去<code>new</code>一个<code>woman</code>对象加载婷婷相关数据，然后调用方法。</p>
<p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<pre><code class="go">package singleton

import (
    &quot;sync&quot;
)

type singleton struct &#123;&#125;

var instance *singleton
var once sync.Once

func GetInstance() *singleton &#123;
    once.Do(func() &#123;
        instance = &amp;singleton&#123;&#125;
    &#125;)
    return instance
&#125;
</code></pre>
<p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h2 id="4-5-sync-Map——Map的并发"><a href="#4-5-sync-Map——Map的并发" class="headerlink" title="4.5 sync.Map——Map的并发"></a>4.5 sync.Map——Map的并发</h2><p>Go 语言中内置的 <code>map</code> 不是并发安全的，请看下面这段示例代码：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
)

var m = make(map[string]int)

func get(key string) int &#123;
    return m[key]
&#125;

func set(key string, value int) &#123;
    m[key] = value
&#125;

func main() &#123;
    wg := sync.WaitGroup&#123;&#125;
    for i := 0; i &lt; 10; i++ &#123;
        wg.Add(1)
        go func(n int) &#123;
            key := strconv.Itoa(n)
            set(key, n)
            fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, get(key))
            wg.Done()
        &#125;(i)
    &#125;
    wg.Wait()
&#125;
</code></pre>
<p>将上面的代码编译后执行，会报出<code>fatal error: concurrent map writes</code>错误。<font color="red">我们不能在多个 <code>goroutine</code> 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。</font></p>
<p>像这种场景下就需要为 <code>map</code> 加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版 map——<code>sync.Map</code>。开箱即用表示其不用像内置的 <code>map</code> 一样使用 <code>make</code> 函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>func (m *Map) Store(key, value interface&#123;&#125;)</code></td>
<td>存储key-value数据</td>
</tr>
<tr>
<td><code>func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool)</code></td>
<td>查询key对应的value</td>
</tr>
<tr>
<td><code>func (m *Map) LoadOrStore(key, value interface&#123;&#125;) (actual interface&#123;&#125;, loaded bool)</code></td>
<td>查询或存储key对应的value</td>
</tr>
<tr>
<td><code>func (m *Map) LoadAndDelete(key interface&#123;&#125;) (value interface&#123;&#125;, loaded bool)</code></td>
<td>查询并删除key</td>
</tr>
<tr>
<td><code>func (m *Map) Delete(key interface&#123;&#125;)</code></td>
<td>删除key</td>
</tr>
<tr>
<td><code>func (m *Map) Range(f func(key, value interface&#123;&#125;) bool)</code></td>
<td>对map中的每个key-value依次调用f</td>
</tr>
</tbody></table>
<p>下面的代码示例演示了并发读写<code>sync.Map</code>：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
)

// 并发安全的map
var m = sync.Map&#123;&#125;

func main() &#123;
    wg := sync.WaitGroup&#123;&#125;
    // 对m执行20个并发的读写操作
    for i := 0; i &lt; 20; i++ &#123;
        wg.Add(1)
        go func(n int) &#123;
            key := strconv.Itoa(n)
            m.Store(key, n)         // 存储key-value
            m.LoadOrStore(key, n)   // 查询或存储key对应的value
            value, _ := m.Load(key) // 根据key取值
            fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, value)
            fmt.Println(m.LoadAndDelete(key)) // 查询并删除key
            m.Delete(key)                     // 删除key
            wg.Done()
            fmt.Println(&quot;---------&quot;)
        &#125;(i)
    &#125;
    wg.Wait()
&#125;
</code></pre>
<h1 id="伍-原子操作——操作整型数据的锁操作"><a href="#伍-原子操作——操作整型数据的锁操作" class="headerlink" title="伍 原子操作——操作整型数据的锁操作"></a>伍 原子操作——操作整型数据的锁操作</h1><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h2 id="5-1-atomic包"><a href="#5-1-atomic包" class="headerlink" title="5.1 atomic包"></a>5.1 atomic包</h2><table>
<thead>
<tr>
<th>方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>func LoadInt32(addr *int32) (val int32)</code></br><code>func LoadInt64(addr *int64) (val int64)</code></br><code>func LoadUint32(addr *uint32) (val uint32)</code></br><code>func LoadUint64(addr *uint64) (val uint64)</code></br><code>func LoadUintptr(addr *uintptr) (val uintptr)</code></br><code>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</code></td>
<td align="center">读取操作</td>
</tr>
<tr>
<td><code>func StoreInt32(addr *int32, val int32)</code></br><code>func StoreInt64(addr *int64, val int64)</code></br><code>func StoreUint32(addr *uint32, val uint32)</code></br><code>func StoreUint64(addr *uint64, val uint64)</code></br><code>func StoreUintptr(addr *uintptr, val uintptr)</code></br><code>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</code></td>
<td align="center">写入操作</td>
</tr>
<tr>
<td><code>func AddInt32(addr *int32, delta int32) (new int32)</code></br><code>func AddInt64(addr *int64, delta int64) (new int64)</code></br><code>func AddUint32(addr *uint32, delta uint32) (new uint32)</code></br><code>func AddUint64(addr *uint64, delta uint64) (new uint64)</code></br><code>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></td>
<td align="center">修改操作</td>
</tr>
<tr>
<td><code>func SwapInt32(addr *int32, new int32) (old int32)</code></br><code>func SwapInt64(addr *int64, new int64) (old int64)</code></br><code>func SwapUint32(addr *uint32, new uint32) (old uint32)</code></br><code>func SwapUint64(addr *uint64, new uint64) (old uint64)</code></br><code>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</code></br><code>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</code></td>
<td align="center">交换操作</td>
</tr>
<tr>
<td><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code></br><code>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</code></br><code>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</code></br><code>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</code></br><code>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</code></br><code>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</code></td>
<td align="center">比较并交换操作</td>
</tr>
</tbody></table>
<h2 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h2><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;sync/atomic&quot;
    &quot;time&quot;
)

type Counter interface &#123;
    Inc()
    Load() int64
&#125;

// 普通版
type CommonCounter struct &#123;
    counter int64
&#125;

func (c CommonCounter) Inc() &#123;
    c.counter++
&#125;

func (c CommonCounter) Load() int64 &#123;
    return c.counter
&#125;

// 互斥锁版
type MutexCounter struct &#123;
    counter int64
    lock    sync.Mutex
&#125;

func (m *MutexCounter) Inc() &#123;
    m.lock.Lock()
    defer m.lock.Unlock()
    m.counter++
&#125;

func (m *MutexCounter) Load() int64 &#123;
    m.lock.Lock()
    defer m.lock.Unlock()
    return m.counter
&#125;

// 原子操作版
type AtomicCounter struct &#123;
    counter int64
&#125;

func (a *AtomicCounter) Inc() &#123;
    atomic.AddInt64(&amp;a.counter, 1)
&#125;

func (a *AtomicCounter) Load() int64 &#123;
    return atomic.LoadInt64(&amp;a.counter)
&#125;

func test(c Counter) &#123;
    var wg sync.WaitGroup
    start := time.Now()
    for i := 0; i &lt; 1000; i++ &#123;
        wg.Add(1)
        go func() &#123;
            c.Inc()
            wg.Done()
        &#125;()
    &#125;
    wg.Wait()
    end := time.Now()
    fmt.Println(c.Load(), end.Sub(start))
&#125;

func main() &#123;
    c1 := CommonCounter&#123;&#125; // 非并发安全
    test(c1)
    c2 := MutexCounter&#123;&#125; // 使用互斥锁实现并发安全
    test(&amp;c2)
    c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高
    test(&amp;c3)
&#125;
</code></pre>
<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 <code>sync</code> 包的函数&#x2F;类型实现同步更好。</p>

    </div>
    
</div>

    <div id="home-card">
        
<div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="/images/f6e2b991f74bfd7b88c3ab1a3d513b94.jpg " alt="avatar">
        </div>
        <div class="name">
            小C&天天
        </div>
        <div class="descriptions">
            
            <div class="description">
                修学储能 先博后渊
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/A7cc">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.qq.com/">
                    <i class="fa-brands fa-qq fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.weibo.com/">
                    <i class="fa-brands fa-weibo fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://google.com/">
                    <i class="fa-brands fa-google fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="http://www.wgs6km.top/">
                    kyrieee个人博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://tonyd0g.gitee.io/">
                    tonyd0g
                </a>
            </div>
            
        </div>
    </div>
    <br />
    <!-- 目录 -->
    
    <div class="card-style" style="width: 300px">
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B9-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">壹 基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%B0-goroutine"><span class="toc-text">贰 goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-goroutine%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 goroutine介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-go%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.2 go关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%90%AF%E5%8A%A8%E5%8D%95%E4%B8%AAgoroutine"><span class="toc-text">2.3 启动单个goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAgoroutine"><span class="toc-text">2.4 启动多个goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%B8%80%E4%BA%9B%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5"><span class="toc-text">2.5 一些理论概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-goroutine%E8%B0%83%E5%BA%A6"><span class="toc-text">2.6 goroutine调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%81-channel%E2%80%94%E2%80%94%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">叁 channel——通道类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-channel%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.1 channel类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-channel%E9%9B%B6%E5%80%BC"><span class="toc-text">2.2 channel零值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96channel"><span class="toc-text">2.3 初始化channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-channel%E6%93%8D%E4%BD%9C"><span class="toc-text">2.4 channel操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-text">2.5 无缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-text">2.6 有缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.7 多返回值模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-for-range%E6%8E%A5%E6%94%B6%E5%80%BC"><span class="toc-text">2.8 for range接收值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93"><span class="toc-text">2.9 单向通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E6%80%BB%E7%BB%93"><span class="toc-text">2.10 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">2.11 select多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E9%80%9A%E9%81%93%E8%AF%AF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.12 通道误用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%82%86-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81"><span class="toc-text">肆 并发安全和锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">4.1 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">4.2 读写互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-sync-WaitGroup%E2%80%94%E2%80%94%E7%AD%89%E5%BE%85%E7%BB%84"><span class="toc-text">4.3 sync.WaitGroup——等待组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-sync-Once%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1-amp-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.4 sync.Once——高并发下仅执行一次&amp;单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.4.1 加载配置文件示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.4.2 并发安全的单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-sync-Map%E2%80%94%E2%80%94Map%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-text">4.5 sync.Map——Map的并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%8D-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E9%94%81%E6%93%8D%E4%BD%9C"><span class="toc-text">伍 原子操作——操作整型数据的锁操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-atomic%E5%8C%85"><span class="toc-text">5.1 atomic包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">5.2 示例</span></a></li></ol></li></ol>
        </div>    
    </div>
    
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
            <script>
                var now = new Date(); 
                function createtime() { 
                    var grt= new Date("07/10/2022 00:00:00");
                    now.setTime(now.getTime()+250); 
                    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                    document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
                } 
            setInterval("createtime()",250);
            </script>
            </div>
        <div>
        <div>
            © 2022 - 2023 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            @小C&天天
        </div>
        <div>
            备案号：小C&天天の窝
        </div>
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

        <!-- 3D模型 -->
        <div id="L2dCanvas" style="position: relative;"></div>
        <script src="/js/live2d.min.js"></script>
        <script src="/css/live2d.css"></script>
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "zhala_2",
                mobile: true,
            });
        </script>
        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
        <!-- 流星背景特效 -->
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/background.js"></script>
    </body>
</html>