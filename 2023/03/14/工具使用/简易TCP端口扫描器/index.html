
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="utf-8" />
        <title>简易TCP端口扫描器 | 小C♥天天</title>
        <meta name="author" content="小C&天天" />
        <meta name="description" content="^v^" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/icon.jpg" />
        <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<!-- 兼容不同版本的浏览器 -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<!-- 高亮代码 -->
<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"/>
<script src="/js/lib/highlight.js"></script>


<!-- 使用 KaTeX 渲染数学公式 -->
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<!-- 简单的点击图片放大缩小的预览 -->
<script src="/js/lib/preview.js"></script>


<!-- 看板娘 -->
<script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>


<!-- 侧边小功能-->



<!-- 评论设置 -->

<script
    src="https://giscus.app/client.js"
    data-repo="A7cc/giscus-comments"
    data-repo-id="R_kgDOKKSvfw"
    data-category="Announcements"
    data-category-id="DIC_kwDOKKSvf84CYyp2"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>



<script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="layout">
            <!-- 页面加载 -->
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>正在加载</p>
                        <img src="/images/afde9fa65a5742a90b51d6e1211e841e.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/tools">
            <i class="fa-solid fa-tools fa-fw"></i>
            <span>&ensp;工具</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
                <a href="/tools">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tools fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">工具</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div id="article-posts-wrap" true ref="homePostsWrap">
    <div class="article">
        <div>
            <h1>简易TCP端口扫描器</h1>
        </div>
        <div class="info">
            <span class="date">
                <span class="icon">
                    <i class="fa-solid fa-calendar fa-fw"></i>
                </span>
                2023/3/14
            </span>
            
            <span class="category">
                <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">
                    <span class="icon">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </span>
                    工具使用
                </a>
            </span>
            
            
            <span class="tags">
                <span class="icon">
                    <i class="fa-solid fa-tags fa-fw"></i>
                </span>
                
                
                <span class="tag">
                    
                    <a href="/tags/Golang/" style="color: #00bcd4">Golang</a>
                </span>
                
                <span class="tag">
                    
                    <a href="/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/" style="color: #ffa2c4">端口扫描</a>
                </span>
                
            </span>
            
        </div>
        
        <div class="content" v-pre>
            <h1 id="壹-TCP扫描本质"><a href="#壹-TCP扫描本质" class="headerlink" title="壹 TCP扫描本质"></a>壹 TCP扫描本质</h1><blockquote>
<p>该工具是自己在看《Go黑帽子-渗透测试编程之道》学习写工具时编写的，该工具只进行了单个<code>IP</code>的全端口扫描！</p>
</blockquote>
<p>要想做TCP端口扫描器，我们需要了解<code>TCP</code>的三次握手以及对方机器的<code>ip:port</code>。回顾一下<code>TCP</code>的三次握手：</p>
<ul>
<li>第一次握手：客户端发送<code>syn</code>包，表示通信开始</li>
<li>第二次握手：服务端回复<code>syn-ack</code>作为相应，提示客户端以<code>ack</code>结束</li>
<li>第三次握手：客户端发送<code>ack</code>，通信开始</li>
</ul>
<span id="more"></span>
<p><img src="/images/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/050c3bbb53095299fb19fec7effaaf9a.png" alt="050c3bbb53095299fb19fec7effaaf9a.png"></p>
<h1 id="贰-TCP连接的情况"><a href="#贰-TCP连接的情况" class="headerlink" title="贰 TCP连接的情况"></a>贰 TCP连接的情况</h1><ul>
<li>正常握手</li>
</ul>
<p>连接成功的话，流程如下：<br><img src="/images/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/0b6255ae3f4c57417b9cf27f3eae128f.png" alt="0b6255ae3f4c57417b9cf27f3eae128f.png"></p>
<ul>
<li>连接失败</li>
</ul>
<p>如果端口被关闭，则服务器会发送一个<code>rst</code>数据包而不是<code>syn-ack</code>进行响应，流程如下：<br><img src="/images/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/0dd65771d30b8a307b901f0534caacef.png" alt="0dd65771d30b8a307b901f0534caacef.png"></p>
<ul>
<li>如果有防火墙</li>
</ul>
<p>如果流量被防火墙过滤，那么客户端不会从服务器收到任何响应，流程如下：<br><img src="/images/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/155aa61b290a0802f78c56bf51cc8401.png" alt="155aa61b290a0802f78c56bf51cc8401.png"></p>
<h1 id="叁-代码实现的TCP端口扫描器"><a href="#叁-代码实现的TCP端口扫描器" class="headerlink" title="叁 代码实现的TCP端口扫描器"></a>叁 代码实现的TCP端口扫描器</h1><p>在Go中，我们通常使用<code>net.Dial</code>进行TCP连接，该函数可以创建<code>UNIX</code>套接字、<code>UDP</code>和第4层协议的连接，需要两个参数：</p>
<ul>
<li>第一个为我们使用的连接类型</li>
<li>第二个参数为我们的连接地址和端口，</li>
</ul>
<p>如何判断连接是否成功，分两种情况：</p>
<ul>
<li><strong>成功</strong>：返回<code>conn</code></li>
<li><strong>失败</strong>：<code>err != nil</code></li>
</ul>
<h2 id="3-1-简易版"><a href="#3-1-简易版" class="headerlink" title="3.1 简易版"></a>3.1 简易版</h2><p>写工具的第一步，先完成基本功能：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
)

func main() &#123;
    // 设置IP:端口
    IP := &quot;192.168.239.142:22&quot;
    // 创建TCP连接
    conn, err := net.Dial(&quot;tcp&quot;, IP)
    // 判断端口是否打开
    if err != nil &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m]&quot;, IP, &quot;端口是关闭的！&quot;)
        // 这里不需要关闭连接，因为端口关闭，没有连接资源占用
    &#125; else &#123;
        fmt.Println(&quot;[\033[32;1m+\033[0m]&quot;, IP, &quot;端口是打开的！&quot;)
        // 关闭连接，减少资源占用
        conn.Close()
    &#125;
&#125;

// [+] 192.168.239.142:22端口是打开的！
</code></pre>
<h2 id="3-2-批量化"><a href="#3-2-批量化" class="headerlink" title="3.2 批量化"></a>3.2 批量化</h2><p>上面是对单个端口的扫描，但是在实际情况下，我们要对多个端口进行扫描，例如我们需要对<code>1-65535</code>个端口扫描，我们可以使用<code>for</code>循环：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
)

func main() &#123;
    // 设置IP:端口
    IP := &quot;192.168.239.142&quot;
    // 创建TCP连接
    for i := 1; i &lt;= 65535; i++ &#123;
        // 使用fmt包中的Sprintf函数将端口进行拼接
        address := fmt.Sprintf(&quot;%s:%d&quot;, IP, i)
        conn, err := net.Dial(&quot;tcp&quot;, address)
        // 判断端口是否打开
        if err != nil &#123;
            // fmt.Printf(&quot;[\033[31;1m-\033[0m] %d 端口是关闭的！\n&quot;, i)
            // 该端口关闭，然后跳过该端口连接
            continue
        &#125;
        // 关闭连接，减少资源占用
        conn.Close()
        // 输出端口信息
        fmt.Printf(&quot;[\033[32;1m+\033[0m] %d 端口是打开的！\n&quot;, i)
    &#125;
&#125;
// [+] 22 端口是打开的！
// [+] 25 端口是打开的！
</code></pre>
<h2 id="3-3-并发扫描"><a href="#3-3-并发扫描" class="headerlink" title="3.3 并发扫描"></a>3.3 并发扫描</h2><p>前面的批量版，我们可以看出，<code>net.Dial</code>如果连接的是未开放的端口，会非常慢，这时候我们就需要使用多线程扫描，即并发扫描，在<code>Go</code>语言中，通过<code>goroutine</code>设置多线程扫描：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() &#123;
    // 设置全局创建同步计数器wg
    var wg sync.WaitGroup
    // 设置IP:端口
    IP := &quot;192.168.239.142&quot;
    // 设置开始时间
    var begin = time.Now()
    // 创建TCP连接
    for i := 1; i &lt;= 65535; i++ &#123;
        // 计数器加一
        wg.Add(1)
        // 使用goroutine创建多线程
        go func(j int) &#123;
            // 在函数执行结束时计数器减一
            defer wg.Done()
            // 使用fmt包中的Sprintf函数将端口进行拼接
            address := fmt.Sprintf(&quot;%s:%d&quot;, IP, j)
            conn, err := net.Dial(&quot;tcp&quot;, address)
            // 判断端口是否打开
            if err != nil &#123;
                // fmt.Printf(&quot;[\033[31;1m-\033[0m] %d 端口是关闭的！\n&quot;, j)
                // 该端口关闭，然后跳过该端口的连接关闭
                return
            &#125;
            // 关闭连接，减少资源占用
            conn.Close()
            // 输出端口信息
            fmt.Printf(&quot;[\033[32;1m+\033[0m] %d 端口是打开的！\n&quot;, j)
        &#125;(i)
    &#125;
    // 阻塞 等待计数器归零
    wg.Wait()
    // 结束时间
    elapseTime := time.Now().Sub(begin)
    fmt.Println(&quot;耗时:&quot;, elapseTime)
&#125;
// [+] 110 端口是打开的！
// [+] 25 端口是打开的！
// [+] 22 端口是打开的！
// 耗时: 15.161702s
</code></pre>
<p>上面代码中我们创建了同步扫描器，然后每当<code>for</code>循环循环一次，我们给我们的同步计数器使用<code>Add</code>函数加<code>1</code>，然后在我们的子线程的函数中，我们使用了<code>defer</code>在函数结束时，通过<code>Done()</code>函数，将我们的计数器减<code>1</code>，代表一个端口扫描已经完成了。然后回到我们的主函数，这里是最关键的，我们使用了<code>Wait()</code>将主函数阻塞，只有当计数器为<code>0</code>时，该函数才会解除阻塞，也就是说，只有当我们的扫描<code>1024</code>个端口的函数全部执行完成，计数器归<code>0</code>时，阻塞才会停止，我们的主函数也就运行结束，程序执行完成。<font color="red">其实是同时开启了<code>6W</code>多个线程，去扫描每个<code>ip:port</code>，所以耗时<strong>最长的线程结束的时间</strong>，就是程序结束的时间</font>。</p>
<h2 id="3-4-线程池版"><a href="#3-4-线程池版" class="headerlink" title="3.4 线程池版"></a>3.4 线程池版</h2><p>上面我们我们直接打开了<code>6W</code>多个线程，虽然在<code>Go</code>中，理论上开个几十万个都没问题，但是实际上是非常占用资源的，这时候我们可以采用<strong>线程池</strong>方式进行优化。我们使用的<code>Go</code>的线程池包：<code>gohive</code>，官方地址：<a target="_blank" rel="noopener" href="https://github.com/loveleshsharma/gohive">传送门</a><br><a href="/tools/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/gohive-master.zip">gohive-master.zip</a></p>
<blockquote>
<p><code>gohive</code>简单介绍：包gohive为Go实现了一个简单易用的goroutine池</p>
<ul>
<li>可以根据需求创建具有特定大小的池</li>
<li>通过实现同步提供高效的性能，其中的工人在不使用时自动回收</li>
<li>实现一个任务队列，如果提交的任务超过池容量，该任务队列可以保持等待中的剩余任务</li>
<li>实现<code>PoolService</code>类型，它作为一个易于使用的<code>API</code>，具有与<code>gohive</code>交互的简单方法</li>
<li>优雅地处理紧急情况并防止应用程序崩溃或陷入死锁</li>
<li>提供如下函数：<code>AvailableWorkers()</code>， <code>ActiveWorkers()</code>和<code>Close()</code>等。</li>
</ul>
</blockquote>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;sync&quot;
    &quot;time&quot;

    &quot;github.com/loveleshsharma/gohive&quot;
)

// 设置全局创建同步计数器wg
var wg sync.WaitGroup

// 地址管道,100容量
var addressChan = make(chan string, 100)

// 管道函数
func worker() &#123;
    // 在函数执行结束时计数器减一
    defer wg.Done()
    for &#123;
        address, ok := &lt;-addressChan
        if !ok &#123;
            break
        &#125;
        conn, err := net.Dial(&quot;tcp&quot;, address)
        // 判断端口是否打开
        if err != nil &#123;
            // fmt.Printf(&quot;[\033[31;1m-\033[0m] %s 端口是关闭的！\n&quot;, address)
            // 该端口关闭，然后跳过该端口连接
            return
        &#125;
        // 关闭连接，减少资源占用
        conn.Close()
        // 输出端口信息
        fmt.Printf(&quot;[\033[32;1m+\033[0m] %s 端口是打开的！\n&quot;, address)
    &#125;
&#125;
func main() &#123;

    // 设置IP:端口
    IP := &quot;192.168.239.142&quot;
    //线程池大小
    var pool_size = 70000
    var pool = gohive.NewFixedSizePool(pool_size)
    // 设置开始时间
    begin := time.Now()
    // 启动一个线程,用于生成ip:port,并且存放到地址管道种
    go func() &#123;
        // 创建TCP连接
        for i := 1; i &lt;= 65535; i++ &#123;
            // 使用fmt包中的Sprintf函数将端口进行拼接
            address := fmt.Sprintf(&quot;%s:%d&quot;, IP, i)
            //将address添加到地址管道
            //fmt.Println(&quot;&lt;-:&quot;,address)
            addressChan &lt;- address
        &#125;
        //发送完关闭 addressChan 管道
        close(addressChan)
    &#125;()

    //启动pool_size工人,处理addressChan种的每个地址
    for work := 0; work &lt; pool_size; work++ &#123;
        // 计数器加一
        wg.Add(1)
        pool.Submit(worker)
    &#125;
    // 阻塞 等待计数器归零
    wg.Wait()
    // 结束时间
    fmt.Println(&quot;耗时:&quot;, time.Now().Sub(begin))
&#125;
// [+] 192.168.239.142:25 端口是打开的！
// [+] 192.168.239.142:110 端口是打开的！
// [+] 192.168.239.142:22 端口是打开的！
// 耗时: 15.2146358s
</code></pre>
<p>我设置的线程池大小是<code>7w</code>个，所以也是一下子开启<code>6w</code>多个协程的，但是我们已经可以进行线程大小约束了。假设现在有这样的去求，有<code>100</code>个<code>ip</code>，需要扫描每个<code>ip</code>开放的端口，如果采用简单粗暴开线程的方式。那就是<code>100+65535=6552300</code>，<code>600w</code>多个线程，还是比较消耗内存的，可能系统就会崩溃，如果采用线程池方式。将线程池控制在<code>50w</code>个，或许情况就会好很多。但是有一点的是，在<code>Go</code>中，线程池通常需要配合<code>chan</code>使用，可能需要不错的基础。</p>
<h2 id="3-5-通过通道控制扫描数量"><a href="#3-5-通过通道控制扫描数量" class="headerlink" title="3.5 通过通道控制扫描数量"></a>3.5 通过通道控制扫描数量</h2><p>除了使用线程池的方法控制扫描数量，我们也可以使用通道进行控制。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

// 端口扫描函数
func Portscan(ports chan int, IP string, wg *sync.WaitGroup) &#123;
    // 根据通道内的数量进行循环扫描，所以刚开始是没有缓冲值的，需要给通道缓冲赋值
    for p := range ports &#123;
        // 使用fmt包中的Sprintf函数将端口进行拼接
        address := fmt.Sprintf(&quot;%s:%d&quot;, IP, p)
        conn, err := net.Dial(&quot;tcp&quot;, address)
        // 判断端口是否打开
        if err != nil &#123;
            // fmt.Printf(&quot;[\033[31;1m-\033[0m] %d 端口是关闭的！\n&quot;, j)
            // 需要注意存在两种情况，一种是端口没有打开，一种是打开打开了，所以需要两次wg.Done()
            // 端口关闭的情况下计数器减一
            wg.Done()
            // 该端口关闭，然后跳过该端口的连接关闭
            continue
        &#125;
        // 关闭连接，减少资源占用
        conn.Close()
        // 输出端口信息
        fmt.Printf(&quot;[\033[32;1m+\033[0m] %d 端口是打开的！\n&quot;, p)
        // 端口打开的情况下计数器减一
        wg.Done()
    &#125;
&#125;

func main() &#123;
    // IP地址
    IP := &quot;192.168.239.142&quot;
    // 创建5000个通道缓冲
    ports := make(chan int, 5000)
    // 设置全局创建同步计数器wg
    var wg sync.WaitGroup
    // 设置开始时间
    var begin = time.Now()
    // 获取通道缓冲并创建对应数量通道线程，注意这里还不会进入扫描，只是会创建这些数量通道线程
    for i := 0; i &lt; cap(ports); i++ &#123;
        // 使用goroutine创建多线程
        go Portscan(ports, IP, &amp;wg)
    &#125;
    // 循环65535个端口，并添加通道缓冲值
    for i := 1; i &lt;= 65535; i++ &#123;
        // 计数器加一
        wg.Add(1)
        // 给通道缓冲赋值
        ports &lt;- i
    &#125;
    // 阻塞 等待计数器归零
    wg.Wait()
    // 关闭通道
    close(ports)
    // 结束时间
    elapseTime := time.Now().Sub(begin)
    fmt.Println(&quot;耗时:&quot;, elapseTime)
&#125;
</code></pre>
<p>这个方法不需要引入别的库，但是我们可以发现存在两个问题：</p>
<ul>
<li>端口输出的顺序比较乱</li>
<li><code>Portscan</code>函数不能返回值到主函数</li>
</ul>
<h2 id="3-5-通过通道控制扫描数量进阶"><a href="#3-5-通过通道控制扫描数量进阶" class="headerlink" title="3.5 通过通道控制扫描数量进阶"></a>3.5 通过通道控制扫描数量进阶</h2><p>由于上一节存在的问题，这时候我们可以追加一个通道，用于存储端口扫描返回值状态，并且用一个列表存储扫描成功后的端口。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;sort&quot;
    &quot;time&quot;
)

// 端口扫描函数
func Portscan(ports, results chan int, IP string) &#123;
    // 根据通道内的数量进行循环扫描，所以刚开始是没有缓冲值的，需要给通道缓冲赋值
    for p := range ports &#123;
        // 使用fmt包中的Sprintf函数将端口进行拼接
        address := fmt.Sprintf(&quot;%s:%d&quot;, IP, p)
        conn, err := net.Dial(&quot;tcp&quot;, address)
        // 判断端口是否打开，如果关闭给results传递一个0，否则传递端口
        // 由于results通道是1，所以如果通道已满会进行堵塞，使得线程也进行堵塞，到达了对sync.WaitGroup的依赖
        if err != nil &#123;
            results &lt;- 0
            // 该端口关闭，然后跳过该端口的连接关闭
            continue
        &#125;
        // 关闭连接，减少资源占用
        conn.Close()
        results &lt;- p
    &#125;
&#125;

func main() &#123;
    // IP地址
    IP := &quot;192.168.239.1&quot;
    // 需要扫描多少端口
    portsnum := 65535
    // 创建5000个通道缓冲
    ports := make(chan int, 5000)
    // 用于存储端口扫描返回值状态
    results := make(chan int)
    // 存储扫描成功后的端口
    var openports []int
    // 设置开始时间
    var begin = time.Now()
    // 获取通道缓冲并创建对应数量通道线程，注意这里还不会进入扫描，只是会创建这些数量通道线程
    for i := 0; i &lt; cap(ports); i++ &#123;
        // 使用goroutine创建多线程
        go Portscan(ports, results, IP)
    &#125;
    // 循环65535个端口，并添加通道缓冲值
    // 之所以使用goroutine创建线程，防止该循环堵塞，而不进行端口赋值
    go func() &#123;
        for i := 1; i &lt;= portsnum; i++ &#123;
            ports &lt;- i
        &#125;
    &#125;()
    // 将端口赋值给列表中
    for i := 0; i &lt; portsnum; i++ &#123;
        port := &lt;-results
        // 判断返回值是否为0，否则添加到列表里
        if port != 0 &#123;
            openports = append(openports, port)
        &#125;
    &#125;
    // 关闭通道
    close(ports)
    close(results)
    // 对端口列表排序
    sort.Ints(openports)
    // 输出端口
    for _, port := range openports &#123;
        fmt.Printf(&quot;[\033[32;1m+\033[0m] %d 端口是打开的！\n&quot;, port)
    &#125;
    // 结束时间
    elapseTime := time.Now().Sub(begin)
    fmt.Println(&quot;耗时:&quot;, elapseTime)
&#125;
</code></pre>
<p>根据上面的方法，我们可以看到不但解决了上一节的两个问题，还消除了对<code>sync.WaitGroup</code>的依赖。</p>
<h1 id="肆-自写简易TCP端口扫描器工具"><a href="#肆-自写简易TCP端口扫描器工具" class="headerlink" title="肆 自写简易TCP端口扫描器工具"></a>肆 自写简易TCP端口扫描器工具</h1><pre><code class="go">package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;os&quot;
    &quot;sort&quot;
    &quot;time&quot;
)

// 标记
func tagPrint() &#123;
    fmt.Println(&quot;\033[31;1m====================================================\033[0m\033[34;1m&quot;)
    fmt.Println(&quot;        ______  ____\033[31;1m_\033[0m\033[34;1m__\033[31;1m___\033[0m\033[34;1m_____\033[31;1m___&quot;)
    fmt.Println(&quot;       /\033[0m\033[34;1m      ||   。       \033[33;1m。\033[0m\033[34;1m   /    T00ls:端口扫描&quot;)
    fmt.Println(&quot;      /  _    \033[31;1m|\033[0m\033[34;1m|____\033[31;1m__\033[0m\033[34;1m_     _  _/&quot;)
    fmt.Println(&quot;     \033[31;1m/\033[0m\033[34;1m  \033[31;1m/ |\033[0m\033[34;1m   |       /    /\033[31;1m( )\033[0m\033[34;1m&quot;)
    fmt.Println(&quot;    /  \033[31;1m/_\033[0m\033[34;1m_|   |      \033[31;1m/\033[0m\033[34;1m    /   ( )       &quot;)
    fmt.Println(&quot;   /  ____    \033[31;1m|\033[0m\033[34;1m  \033[35;1m&lt;-—+—++—+--&#125;\033[0m\033[34;1m\033[31;1m( )\033[0m\033[34;1m____\033[31;1m/|\033[0m\033[34;1m&quot;)
    fmt.Println(&quot;  \033[31;1m/\033[0m\033[34;1m  /    |   |    /    /    ( \033[33;1m.\033[0m\033[34;1m   . \033[31;1m)\033[0m\033[34;1m&quot;)
    fmt.Println(&quot; /\033[31;1m_\033[0m\033[34;1m_/     |_\033[31;1m__|\033[0m\033[34;1m   \033[31;1m/_\033[0m\033[34;1m___/     (\033[31;1m__\033[0m\033[34;1m__=___)  \033[31;1m❤\033[0m&quot;)
    fmt.Println(&quot;\033[0m\033[31;1m====================================================\033[0m&quot;)
&#125;

// 端口扫描函数
func portScanner(ports, results chan int, IP string) &#123;
    // 根据通道内的数量进行循环扫描，所以刚开始是没有缓冲值的，需要给通道缓冲赋值
    for p := range ports &#123;
        // 使用fmt包中的Sprintf函数将端口进行拼接
        address := fmt.Sprintf(&quot;%s:%d&quot;, IP, p)
        conn, err := net.Dial(&quot;tcp&quot;, address)
        // 判断端口是否打开，如果关闭给results传递一个0，否则传递端口
        // 由于results通道是1，所以如果通道已满会进行堵塞，使得线程也进行堵塞，到达了对sync.WaitGroup的依赖
        if err != nil &#123;
            results &lt;- 0
            // 该端口关闭，然后跳过该端口的连接关闭
            continue
        &#125;
        // 关闭连接，减少资源占用
        conn.Close()
        results &lt;- p
    &#125;
&#125;

func main() &#123;
    // 输出tag
    tagPrint()
    // 设置查看进度的开关
    top := true
    // 输入IP
    var IP string
    flag.StringVar(&amp;IP, &quot;ip&quot;, &quot;&quot;, &quot;IP地址&quot;)
    // 解析命令行参数
    flag.Parse()
    if IP == &quot;&quot; &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m] 没有输入IP！&quot;)
        flag.Usage()
        os.Exit(0)
    &#125;
    // 需要扫描多少端口
    portsnum := 65535
    // 创建30000个通道缓冲
    ports := make(chan int, 30000)
    // 用于存储端口扫描返回值状态
    results := make(chan int)
    // 存储扫描成功后的端口
    var openports []int
    // 设置开始时间
    var begin = time.Now()
    fmt.Println(&quot;[\033[33;1m*\033[0m] 扫描开始！&quot;)
    // 用于查看进度，表示还在扫描
    go func() &#123;
        for top &#123;
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;\r[\033[34;1m—\033[0m] 扫描中，请耐心等待。。。&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;\r[\033[34;1m\\\033[0m] 扫描中，请耐心等待。。。&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;\r[\033[34;1m|\033[0m] 扫描中，请耐心等待。。。&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;\r[\033[34;1m/\033[0m] 扫描中，请耐心等待。。。&quot;)
        &#125;
        fmt.Println()
    &#125;()
    // 获取通道缓冲并创建对应数量通道线程，注意这里还不会进入扫描，只是会创建这些数量通道线程
    for i := 0; i &lt; cap(ports); i++ &#123;
        // 使用goroutine创建多线程
        go portScanner(ports, results, IP)
    &#125;
    // 循环65535个端口，并添加通道缓冲值
    // 之所以使用goroutine创建线程，防止该循环堵塞，而不进行端口赋值
    go func() &#123;
        for i := 1; i &lt;= portsnum; i++ &#123;
            ports &lt;- i
        &#125;
    &#125;()
    // 将端口赋值给列表中
    for i := 0; i &lt; portsnum; i++ &#123;
        port := &lt;-results
        // 判断返回值是否为0，否则添加到列表里
        if port != 0 &#123;
            openports = append(openports, port)
        &#125;
    &#125;
    // 关闭通道
    close(ports)
    close(results)
    // 对端口列表排序
    sort.Ints(openports)
    top = false
    fmt.Printf(&quot;\r&quot;)
    // 结束时间
    elapseTime := time.Now().Sub(begin)
    fmt.Println(&quot;[\033[33;1m*\033[0m]&quot;, IP, &quot;扫描结束，耗时:&quot;, elapseTime)
    // 输出端口
    for _, port := range openports &#123;
        fmt.Printf(&quot;[\033[32;1m+\033[0m] %d 端口是打开的！\n&quot;, port)
    &#125;
&#125;
</code></pre>
<h1 id="伍-总结"><a href="#伍-总结" class="headerlink" title="伍 总结"></a>伍 总结</h1><p>对于该工具的编写主要使用四种方式来实现功能：</p>
<ul>
<li><strong>正常</strong>：没有并发,速度很慢</li>
<li><strong>多协程</strong>：并发，性能很高，但是协程太多可能会崩溃</li>
<li><strong>线程池</strong>：并发，性能高，协程数量可控</li>
<li><strong>通道</strong>：并发，性能高，协程数量可控，不需要引入外部库，消除了对<code>sync.WaitGroup</code>的依赖</li>
</ul>
<p>当然其实还可以通过<code>net.DialTimeout</code>连接<code>ip:port</code>这个可以设置超时时间，比如超时<code>5s</code>就判定端口未开放，通常情况下，如果基础可以，更<strong>推荐</strong>使用通道方式，加上上面程序是单个<code>IP</code>的扫描，我们也可以使用多个<code>IP</code>。</p>
<h1 id="陆-参考"><a href="#陆-参考" class="headerlink" title="陆 参考"></a>陆 参考</h1><ul>
<li>书籍：《Go黑帽子-渗透测试编程之道》</li>
</ul>

        </div>
        
        
        <div id="comment">
            <div id="giscus-container" class="giscus"></div>
        </div>
        
    </div>
    
    <div id="article-card">
        <div id="card-style">
    <div id="card-div" class="card-cls">
        <div class="avatar">
            <img src="/images/f6e2b991f74bfd7b88c3ab1a3d513b94.jpg" alt="avatar" />
        </div>
        <div class="name">小C&amp;天天</div>
        <div class="description">
            <p>修学储能 先博后渊</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/A7cc">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.qq.com/">
                    <i class="fa-brands fa-qq fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.weibo.com/">
                    <i class="fa-brands fa-weibo fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://google.com/">
                    <i class="fa-brands fa-google fa-fw"></i>
                </a>
            </span>
            
        </div>
        
        
        <div class="friend-links">
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="http://www.wgs6km.top/">kyrieee</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://tonyd0g.gitee.io/">tonyd0g</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://ruyueattention.github.io/">ruyueattention</a>
            </span>
            
        </div>
        
    </div>
    
    <!-- <br /> -->
    <!-- 目录 -->
    <!-- 
    <div id="card-div">
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B9-TCP%E6%89%AB%E6%8F%8F%E6%9C%AC%E8%B4%A8"><span class="toc-text">壹 TCP扫描本质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%B0-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">贰 TCP连接的情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%81-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9A%84TCP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8"><span class="toc-text">叁 代码实现的TCP端口扫描器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%80%E6%98%93%E7%89%88"><span class="toc-text">3.1 简易版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%89%B9%E9%87%8F%E5%8C%96"><span class="toc-text">3.2 批量化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%B9%B6%E5%8F%91%E6%89%AB%E6%8F%8F"><span class="toc-text">3.3 并发扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88"><span class="toc-text">3.4 线程池版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%80%9A%E8%BF%87%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%89%AB%E6%8F%8F%E6%95%B0%E9%87%8F"><span class="toc-text">3.5 通过通道控制扫描数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%80%9A%E8%BF%87%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%89%AB%E6%8F%8F%E6%95%B0%E9%87%8F%E8%BF%9B%E9%98%B6"><span class="toc-text">3.5 通过通道控制扫描数量进阶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%82%86-%E8%87%AA%E5%86%99%E7%AE%80%E6%98%93TCP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">肆 自写简易TCP端口扫描器工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%8D-%E6%80%BB%E7%BB%93"><span class="toc-text">伍 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%86-%E5%8F%82%E8%80%83"><span class="toc-text">陆 参考</span></a></li></ol>
        </div>    
    </div>
     -->
</div>

<div id="card-style-fun">
    
    <!-- 今日诗句 -->
    <br />
    <div id="card-div">
        <div class="good-sentence">
            <div class="toolio">
                <div class="circle"><span class="red"></span></div>
                <div class="circle"><span class="yellow"></span></div>
                <div class="circle"><span class="green"></span></div>
                <div class="circle"><span class="text">今日诗句</span></div>
            </div>
            <div class="sentence">
                <div id="sentenceid" onload="getsentence();"></div>
            </div>
        </div>
    </div>
    <!-- 日期信息 -->
    <br />
    <div id="card-div">
        <img src="//api.vvhan.com/api/ipCard?tip=A7cc" width="300" height="180">
    </div>
    
</div>



    </div>
    
</div>
                <!-- 页脚 -->
                <footer id="footer">
    <div id="footer-wrap">
        <div>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
            <script>
                var now = new Date(); 
                function createtime() { 
                    var grt= new Date("07/10/2022 00:00:00");
                    now.setTime(now.getTime()+250); 
                    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                    document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
                } 
            setInterval("createtime()",250);
            </script>
        </div>
        <div>
            &copy;
            2022 - 2024 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            &commat;小C&amp;天天
        </div>
        <div>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX</a> 
        </div>
        
    </div>
</footer>

            </div>
            <!-- 简单的点击图片放大缩小的预览 -->
            
            <div name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </div>
            
        </div>
        <!-- 看板娘 -->
        
        <div id="L2dCanvas"></div>
        <script src="/js/lib/live2d.min.js"></script>
        <!-- 设置随机模板 -->
        
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "heitaizi_2",
                mobile: true,
            });
        </script>
        
        <!-- 诗句 -->
        
        <script>
            // // 每隔10分钟执行一次getsentence这个函数
            window.setInterval(getsentence, 100*60*5);
            function getsentence() {
                // 这里没有考虑IE浏览器，如果需要择if判断加
                var xhr = new XMLHttpRequest();  
                xhr.open('GET', "https://zj.v.api.aa1.cn/api/wenan-shici/?type=json",true);
                xhr.send(JSON.stringify(null));
                xhr.onreadystatechange = function () {
                    if (xhr.status === 200 && xhr.readyState === 4) {
                        //js处理数据
                        // xhr.responseText.match(/content":(".+?")/g)
                        getdata = JSON.parse(xhr.responseText).msg;
                    }else{
                        getdata = "长风破浪会有时，直挂云帆济沧海。——李白《行路难》";
                    }
                    document.getElementById("sentenceid").innerHTML = getdata;
                }
            }
            window.onload = getsentence;
        </script>
        
        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
        <!-- 流星背景特效 -->
        
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/meteorbackground.js"></script>
        
        <script src="/js/main.js"></script>
    </body>
</html>
