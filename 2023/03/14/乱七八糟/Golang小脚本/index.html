
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="utf-8" />
        <title>Golang小脚本（持续更新） | 小C♥天天</title>
        <meta name="author" content="小C&天天" />
        <meta name="description" content="^v^" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/icon.jpg" />
        <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<!-- 兼容不同版本的浏览器 -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<!-- 高亮代码 -->
<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"/>
<script src="/js/lib/highlight.js"></script>


<!-- 使用 KaTeX 渲染数学公式 -->
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<!-- 简单的点击图片放大缩小的预览 -->
<script src="/js/lib/preview.js"></script>


<!-- 看板娘 -->
<script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>



<!-- 评论设置 -->

<script
    src="https://giscus.app/client.js"
    data-repo="A7cc/giscus-comments"
    data-repo-id="R_kgDOKKSvfw"
    data-category="Announcements"
    data-category-id="DIC_kwDOKKSvf84CYyp2"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>



<script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="layout">
            <!-- 页面加载 -->
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>正在加载</p>
                        <img src="/images/afde9fa65a5742a90b51d6e1211e841e.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/tools">
            <i class="fa-solid fa-tools fa-fw"></i>
            <span>&ensp;工具</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
                <a href="/tools">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tools fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">工具</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div id="article-posts-wrap" true ref="homePostsWrap">
    <div class="article">
        <div>
            <h1>Golang小脚本（持续更新）</h1>
        </div>
        <div class="info">
            <span class="date">
                <span class="icon">
                    <i class="fa-solid fa-calendar fa-fw"></i>
                </span>
                2023/3/14
            </span>
            
            <span class="category">
                <a href="/categories/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/">
                    <span class="icon">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </span>
                    乱七八糟
                </a>
            </span>
            
            
            <span class="tags">
                <span class="icon">
                    <i class="fa-solid fa-tags fa-fw"></i>
                </span>
                
                
                <span class="tag">
                    
                    <a href="/tags/Golang/" style="color: #00bcd4">Golang</a>
                </span>
                
            </span>
            
        </div>
        
        <div class="content" v-pre>
            <h1 id="壹-说明"><a href="#壹-说明" class="headerlink" title="壹 说明"></a>壹 说明</h1><p>该文章主要记录平时工作或者生活中经常使用的<code>Golang</code>小脚本。</p>
<span id="more"></span>

<h1 id="贰-小脚本"><a href="#贰-小脚本" class="headerlink" title="贰 小脚本"></a>贰 小脚本</h1><h2 id="2-1-处理错误方法"><a href="#2-1-处理错误方法" class="headerlink" title="2.1 处理错误方法"></a>2.1 处理错误方法</h2><pre><code class="Golang">// 处理错误方法
func HandlingErrors(err error, funname string) &#123;
    if err != nil &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m] &quot;, funname, &quot;Error：&quot;, err)
        log.Panic(err)
    &#125;
&#125;
</code></pre>
<h2 id="2-2-标志"><a href="#2-2-标志" class="headerlink" title="2.2 标志"></a>2.2 标志</h2><pre><code class="Golang">func TagPrint() &#123;
    // tag1
    fmt.Println(&quot;\033[31;1m====================================================\033[0m\033[34;1m&quot;)
    fmt.Println(&quot;        ______  ____\033[31;1m_\033[0m\033[34;1m__\033[31;1m___\033[0m\033[34;1m____\033[31;1m___&quot;)
    fmt.Println(&quot;       /\033[0m\033[34;1m      ||   。      \033[33;1m。\033[0m\033[34;1m   /&quot;)
    fmt.Println(&quot;      /  _    \033[31;1m|\033[0m\033[34;1m|____\033[31;1m__\033[0m\033[34;1m_    _  _/ T00ls:&quot;)
    fmt.Println(&quot;     \033[31;1m/\033[0m\033[34;1m  \033[31;1m/ |\033[0m\033[34;1m   |       /   /\033[31;1m( )\033[0m\033[34;1m   工具名字&quot;)
    fmt.Println(&quot;    /  \033[31;1m/_\033[0m\033[34;1m_|   |      \033[31;1m/\033[0m\033[34;1m   /   ( )       &quot;)
    fmt.Println(&quot;   /  ____    \033[31;1m|\033[0m\033[34;1m  \033[35;1m&lt;-—+—+—+--&#125;\033[0m\033[34;1m\033[31;1m( )\033[0m\033[34;1m____\033[31;1m/|\033[0m\033[34;1m&quot;)
    fmt.Println(&quot;  \033[31;1m/\033[0m\033[34;1m  /    |   |    /   /    ( \033[33;1m.\033[0m\033[34;1m   . \033[31;1m)\033[0m\033[34;1m&quot;)
    fmt.Println(&quot; /\033[31;1m_\033[0m\033[34;1m_/     |_\033[31;1m__|\033[0m\033[34;1m   \033[31;1m/_\033[0m\033[34;1m__/     (\033[31;1m__\033[0m\033[34;1m__=___)  \033[31;1m❤\033[0m&quot;)
    fmt.Println(&quot;\033[0m\033[31;1m====================================================\033[0m&quot;)
&#125;
func TagPrint() &#123;
    // tag2
    fmt.Println(&quot;\033[34;1m++++++++++++++++++++++++++++++++++++++++++++++++++++++++\033[0m\033[31;1m&quot;)
    fmt.Println(&quot;                  ______     _______________            &quot;)
    fmt.Println(&quot;                 /       \\  \\               \\           &quot;)
    fmt.Println(&quot;                /    __   \\  \\___________   /           &quot;)
    fmt.Println(&quot;               /    /  \\   \\         /    /             &quot;)
    fmt.Println(&quot;              /    /    \\   \\       /    /              &quot;)
    fmt.Println(&quot;             /    /______\\   \\   \033[34;1m&lt;—+————+-&#125;\033[0m\033[31;1m             &quot;)
    fmt.Println(&quot;            /    __________   \\    |    |               &quot;)
    fmt.Println(&quot;           /    /          \\   \\   |    |               &quot;)
    fmt.Println(&quot;          /    /            \\   \\  |    |               &quot;)
    fmt.Println(&quot;         /____/              \\___\\ |____|               &quot;)
    fmt.Println(&quot;\033[0m\033[34;1m++++++++++++++++++++++++++++++++++++++++++++++++++++++++\033[0m&quot;)
    // tag3：别人的
    fmt.Println(&quot;\033[36m -------------------------------------------------------- \033[0m&quot;)
    fmt.Println(&quot;\033[31m     ██████╗  █████╗ ████████╗██╗  ██╗███████╗██████╗     \033[0m&quot;)
    fmt.Println(&quot;\033[31m    ██╔════╝ ██╔══██╗╚══██╔══╝██║  ██║██╔════╝██╔══██╗    \033[0m&quot;)
    fmt.Println(&quot;\033[31m    ██║  ███╗███████║   ██║   ███████║█████╗  ██████╔╝    \033[0m&quot;)
    fmt.Println(&quot;\033[31m    ██║   ██║██╔══██║   ██║   ██╔══██║██╔══╝  ██╔══██╗    \033[0m&quot;)
    fmt.Println(&quot;\033[31m    ╚██████╔╝██║  ██║   ██║   ██║  ██║███████╗██║  ██║    \033[0m&quot;)
    fmt.Println(&quot;\033[31m     ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝    \033[0m&quot;)
    fmt.Println(&quot;\033[36m -------------------------------------------------------- \033[0m&quot;)
    // tag4，使用尖锐的角更显得严肃
    tag := `
________   |\
\   ___/___| | _______________|\   ___
 | |__/  __| |/ / __/  __/ _* | \ |* / 
 |  _/\ (__|   &lt;\__ \ (_| (_| | |\| | ❤
 | |   \___| |\__\__/\___\__,_|__\\ |
 |/        |/   version: %8s  \|
`
    fmt.Printf(tag, version)
        // tag5
    tag := `
    ___  /|         /|            |\                |\
   /   |/ |        / |        ____| |__ ______  ____| | __
  / /| || |   __ __| |  _^_  /  __|  _ \   +  /   __| |/ / 
 | |_| || |/|/ //  _ |(_____)\ (__| | | |  __/\  (__|   &lt; 
 |  _  || * ^ *|| |/ | | * |  \___| | |_\______\____| |\__\
 |_| | ||______/\__/\|  \_/       |/                |/
      \|                      比赛名称：` + YELLOW + competition + END
    fmt.Println(tag)
    // tag6：别人的
    fmt.Println(&quot;         ,;;;,     &quot;)
    fmt.Println(&quot;        ;;;;;;;                   &quot;)
    fmt.Println(&quot;     .- `\\, &#39;/_      _____ _    ____  _                      _            &quot;)
    fmt.Println(&quot;   .&#39;   \\  (`(_)    |_   _| |_ |__ / (_)_ _  ____ __  ___ __| |_ ___ _ _ &quot;)
    fmt.Println(&quot;  / `-,. \\ \\_/        | | | &#39; \\ |_ \\ | | &#39; \\(_-&lt; &#39;_ \\/ -_) _|  _/ _ \\ &#39;_| &quot;)
    fmt.Println(&quot;  \\  \\/ \\ `--`        |_| |_||_|___/ |_|_||_/__/ .__/\\___\\__|\\__\\___/_| V 1.9&quot;)
    fmt.Println(&quot;   \\  \\  \\                         \033[0;31m[\033[0;33m127.0.0.1\033[0;31m] \033[0;37m|_|\033[0;31m [\033[1;34m192.168.1.1\033[0;31m] \033[0;37m&quot;)
    fmt.Println(&quot;    / /| |                            \033[0;31m[\033[0;37mCoded BY Mohamed Riahi\033[0;31m]\033[0;37m&quot;)
    fmt.Println(&quot;   /_/ |_|      &quot;)
    fmt.Println(&quot;  ( _\\ ( _\\    #:##       #:##&quot;)
    fmt.Println(&quot;                     #:## &quot;)
&#125;
</code></pre>
<h2 id="2-3-切片去重"><a href="#2-3-切片去重" class="headerlink" title="2.3 切片去重"></a>2.3 切片去重</h2><pre><code class="Golang">// 使用了1.18的泛型，如果使用的是go1.18以下版本建议改成对应类型
// 去重
// 去重函数
func RemoveDuplicate[T any](old []T) (result []T) &#123;
    // 将第一个切片元素赋值，构建一个新的字符串切片
    result = old[:1]
    // 遍历str1的元素
    for _, word := range old &#123;
        i := 0
        for ; i &lt; len(result); i++ &#123;
            if reflect.ValueOf(word).Interface() == reflect.ValueOf(result[i]).Interface() &#123;
                break
            &#125;
        &#125;
        if i == len(result) &#123;
            result = append(result, word)
        &#125;
    &#125;
    return result
&#125;

// 或者
func RemoveDuplicate[T any](old []T) (result []T) &#123;
    temp := map[any]struct&#123;&#125;&#123;&#125;
    for _, item := range old &#123;
        if _, ok := temp[item]; !ok &#123;
            temp[item] = struct&#123;&#125;&#123;&#125;
            result = append(result, item)
        &#125;
    &#125;
    return
&#125;
</code></pre>
<h2 id="2-4-排除内网IP"><a href="#2-4-排除内网IP" class="headerlink" title="2.4 排除内网IP"></a>2.4 排除内网IP</h2><pre><code class="Golang">func DeleteLocalIP(iplist []string) []string &#123;
    // 用于输出排除内网的字符串切片
    var out []string
    // 循环遍历iplist
    for _, v := range iplist &#123;
        // 判断元素是否是内网地址，如果不是增加到out切片
        rege, _ := regexp.Compile(`^(127\.0\.0\.1)|(localhost)|(10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(0.0.0.0)|(172\.((1[6-9])|(2\d)|(3[01]))\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)|(192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)$`)
        matched := rege.MatchString(v)
        if !matched &#123;
            out = append(out, v)
        &#125;
    &#125;
    return out
&#125;
</code></pre>
<h2 id="2-5-IP的正则表达式"><a href="#2-5-IP的正则表达式" class="headerlink" title="2.5 IP的正则表达式"></a>2.5 IP的正则表达式</h2><pre><code class="Golang">regexp.Compile(`[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;`)
</code></pre>
<h2 id="2-6-终端颜色"><a href="#2-6-终端颜色" class="headerlink" title="2.6 终端颜色"></a>2.6 终端颜色</h2><pre><code class="Golang">// 终端颜色
var (
    ERR     string = &quot;[\033[1;31m✘\033[0m]&quot;
    RIGHT   string = &quot;[\033[1;32m✓\033[0m]&quot;
    WARNING string = &quot;[\033[0;38;5;214m!\033[0m]&quot;
    GREY    string = &quot;\033[1;30m&quot;
    RED     string = &quot;\033[1;31m&quot;
    GREEN   string = &quot;\033[1;32m&quot;
    YELLOW  string = &quot;\033[1;33m&quot;
    BLUE    string = &quot;\033[1;34m&quot;
    PURPLE  string = &quot;\033[1;35m&quot;
    MAIN    string = &quot;\033[1;36m&quot;
    ORANGE  string = &quot;\033[0;38;5;214m&quot;
    END     string = &quot;\033[0m&quot;
)
func Tag() &#123;
    fmt.Printf(&quot;\x1b[%dmhello world 30: 黑 \x1b[0m\n&quot;, 30)
    fmt.Printf(&quot;\x1b[%dmhello world 31: 红 \x1b[0m\n&quot;, 31)
    fmt.Printf(&quot;\x1b[%dmhello world 32: 绿 \x1b[0m\n&quot;, 32)
    fmt.Printf(&quot;\x1b[%dmhello world 33: 黄 \x1b[0m\n&quot;, 33)
    fmt.Printf(&quot;\x1b[%dmhello world 34: 蓝 \x1b[0m\n&quot;, 34)
    fmt.Printf(&quot;\x1b[%dmhello world 35: 紫 \x1b[0m\n&quot;, 35)
    fmt.Printf(&quot;\x1b[%dmhello world 36: 深绿 \x1b[0m\n&quot;, 36)
    fmt.Printf(&quot;\x1b[%dmhello world 37: 白色 \x1b[0m\n&quot;, 37)

    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 47: 白色 30: 黑 \n&quot;, 47, 30)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 46: 深绿 31: 红 \n&quot;, 46, 31)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 45: 紫   32: 绿 \n&quot;, 45, 32)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 44: 蓝   33: 黄 \n&quot;, 44, 33)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 43: 黄   34: 蓝 \n&quot;, 43, 34)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 42: 绿   35: 紫 \n&quot;, 42, 35)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 41: 红   36: 深绿 \n&quot;, 41, 36)
    fmt.Printf(&quot;\x1b[%d;%dmhello world \x1b[0m 40: 黑   37: 白色 \n&quot;, 40, 37)
&#125;
</code></pre>
<h2 id="2-7-字符串类型的端口转换为int切片的端口"><a href="#2-7-字符串类型的端口转换为int切片的端口" class="headerlink" title="2.7 字符串类型的端口转换为int切片的端口"></a>2.7 字符串类型的端口转换为int切片的端口</h2><pre><code class="Golang">// 将字符串端口转换为int切片端口
func PortParse(port string) []int &#123;
    var ports []int
    if port == &quot;&quot; &#123;
        // 不设置端口，使用默认端口
        defPort := configs.DefaultPorts
        return defPort
    &#125; else if len(regexp.MustCompile(&quot;-&quot;).FindAllStringIndex(port, -1)) == 1 &#123;

        grep := regexp.MustCompile(&quot;(.*)-(.*)&quot;)
        // 获取IP段的头尾
        portHead := grep.FindStringSubmatch(port)[1]
        portTail := grep.FindStringSubmatch(port)[2]
        // 将IP的头尾转换成int类型
        intHead, _ := strconv.Atoi(portHead)
        intTail, _ := strconv.Atoi(portTail)
        // 赋值IP切片
        for p := intHead; p &lt;= intTail; p++ &#123;
            ports = append(ports, p)
        &#125;
        return ports
    &#125; else &#123;
        // 将IP字符串分开
        CustomPorts := strings.Split(port, &quot;,&quot;)
        // 迭代赋值给int切片
        for _, port := range CustomPorts &#123;
            p, _ := strconv.Atoi(port)
            ports = append(ports, p)
        &#125;
        return ports
    &#125;
&#125;
</code></pre>
<h2 id="2-8-将int转换为字符串"><a href="#2-8-将int转换为字符串" class="headerlink" title="2.8 将int转换为字符串"></a>2.8 将int转换为字符串</h2><pre><code class="Golang">int_1, _ := strconv.Atoi(&quot;asasas&quot;)
str_1 := strconv.Itoa(100)
fmt.Println(int_1)
fmt.Println(str_1)
</code></pre>
<h2 id="2-9-Ping通主机以及判断操作系统类型"><a href="#2-9-Ping通主机以及判断操作系统类型" class="headerlink" title="2.9 Ping通主机以及判断操作系统类型"></a>2.9 Ping通主机以及判断操作系统类型</h2><pre><code class="Golang">// hosthost是主机
// timeout是过期时间
func Ping(host string, timeout int) bool &#123;
    // 将int类型的timeout转换为string类型的timeout
    var to = strconv.Itoa(timeout)
    // ping对应主机
    var cmd *exec.Cmd
    // 判断操作系统
    switch runtime.GOOS &#123;
    case &quot;windows&quot;:
        cmd = exec.Command(&quot;ping&quot;, host, &quot;-n&quot;, &quot;1&quot;, &quot;-w&quot;, to)
    case &quot;linux&quot;:
        cmd = exec.Command(&quot;ping&quot;, host, &quot;-c&quot;, &quot;1&quot;, &quot;-w&quot;, to)
    case &quot;darwin&quot;:
        cmd = exec.Command(&quot;ping&quot;, host, &quot;-c&quot;, &quot;1&quot;, &quot;-W&quot;, to)
    &#125;
    // 判断cmd是否为空
    if cmd == nil &#123;
        return false
    &#125;
    // 执行cmd的命令
    err := cmd.Run()
    return err == nil
&#125;
</code></pre>
<h2 id="2-10-实现SHA256生成散列值"><a href="#2-10-实现SHA256生成散列值" class="headerlink" title="2.10 实现SHA256生成散列值"></a>2.10 实现SHA256生成散列值</h2><pre><code class="Golang">package main
import (
    &quot;crypto/sha256&quot;
    &quot;encoding/hex&quot;
    &quot;fmt&quot;
)
//SHA256生成哈希值
func GetSHA256HashCode(str string)string&#123;
    message := []byte(str)
    //方法一：
    //创建一个基于SHA256算法的hash.Hash接口的对象
    hash := sha256.New()
    //输入数据
    hash.Write(message)
    //计算哈希值
    bytes := hash.Sum(nil)
    //将字符串编码为16进制格式,返回字符串
    hashCode := hex.EncodeToString(bytes)
    //返回哈希值
    return hashCode
    
    //方法二：
    //bytes2:=sha256.Sum256(message)//计算哈希值，返回一个长度为32的数组
    //hashcode2:=hex.EncodeToString(bytes2[:])//将数组转换成切片，转换成16进制，返回字符串
    //return hashcode2
&#125;
func main()&#123;
    hashCode:=GetSHA256HashCode(&quot;hello world&quot;)
    fmt.Println(hashCode)
&#125;
</code></pre>
<h2 id="2-11-获取当前目录下所有文件"><a href="#2-11-获取当前目录下所有文件" class="headerlink" title="2.11 获取当前目录下所有文件"></a>2.11 获取当前目录下所有文件</h2><pre><code class="Golang">func GetAllFile(path string) []string &#123;
    // 存放文件名
    filename := []string&#123;&#125;
    // 读取当前目录中的所有文件和子目录
    files, err := ioutil.ReadDir(path)
    if err != nil &#123;
        panic(err)
    &#125;
    // 获取文件，并输出它们的名字
    for _, file := range files &#123;
        filename = append(filename, file.Name())
    &#125;
    return filename
&#125;
</code></pre>
<h2 id="2-12-生成随机数"><a href="#2-12-生成随机数" class="headerlink" title="2.12 生成随机数"></a>2.12 生成随机数</h2><pre><code class="Golang">package main
 
import &quot;fmt&quot;
import &quot;math/rand&quot;
 
func main() &#123;
 
    fmt.Println(rand.Intn(100)) //产生0-100的随机整数
 
    fmt.Println(rand.Float64()) //产生0.0-1.0的随机浮点点
 
    s1 := rand.NewSource(42) //用指定值创建一个随机数种子
    r1 := rand.New(s1)
    fmt.Print(r1.Intn(100), &quot;,&quot;)
    fmt.Print(r1.Intn(100))
    fmt.Println()
 
    s2 := rand.NewSource(42) //同前面一样的种子
    r2 := rand.New(s2)
    fmt.Print(r2.Intn(100), &quot;,&quot;)
    fmt.Print(r2.Intn(100))
    fmt.Println()
&#125;
</code></pre>
<h2 id="2-13-Base64编码"><a href="#2-13-Base64编码" class="headerlink" title="2.13 Base64编码"></a>2.13 Base64编码</h2><pre><code class="Golang">package main

import (
    &quot;encoding/base64&quot;
    &quot;fmt&quot;
)

func main() &#123;
    info := []byte(&quot;https://www.bilibili.com/aa*()s/?=&quot;)
    fmt.Println(&quot;==============标准的Base64编码==============&quot;)
    encodeinfo := base64.StdEncoding.EncodeToString(info)
    decodeinfo, _ := base64.StdEncoding.DecodeString(encodeinfo)
    fmt.Printf(&quot;编码后：%s，解码后：%s\n&quot;, encodeinfo, decodeinfo)
    fmt.Println(&quot;==============URL的Base64编码==============&quot;)
    URLencodeinfo := base64.URLEncoding.EncodeToString(info)
    URLdecodeinfo, _ := base64.URLEncoding.DecodeString(URLencodeinfo)
    fmt.Printf(&quot;编码后：%s，解码后：%s\n&quot;, URLencodeinfo, URLdecodeinfo)
&#125;
</code></pre>
<h2 id="2-14-判断字符串是否包含某个字符"><a href="#2-14-判断字符串是否包含某个字符" class="headerlink" title="2.14 判断字符串是否包含某个字符"></a>2.14 判断字符串是否包含某个字符</h2><pre><code class="Golang">func main() &#123;
    if find := strings.Contains(&quot;test-v1&quot;, &quot;v1&quot;); find &#123;
        fmt.Println(&quot;find the character.&quot;)
    &#125;
&#125;
</code></pre>
<h2 id="2-15-字符串反转"><a href="#2-15-字符串反转" class="headerlink" title="2.15 字符串反转"></a>2.15 字符串反转</h2><pre><code class="Golang">package main

import &quot;fmt&quot;

func main() &#123;
    s := &quot;foobar&quot;
    a := []rune(s)
    fmt.Printf(&quot;%s\n&quot;, s)
    fmt.Printf(&quot;字符串逆转过程：\n&quot;)
    for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 &#123;
        a[i], a[j] = a[j], a[i]
        fmt.Println(string(a))

    &#125;
    fmt.Printf(&quot;%s\n&quot;, string(a))
&#125;
</code></pre>
<h2 id="2-16-读取json文件"><a href="#2-16-读取json文件" class="headerlink" title="2.16 读取json文件"></a>2.16 读取json文件</h2><pre><code class="Golang">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
)

type Post struct &#123; //带结构标签，反引号来包围字符串
    Id      int       `json:&quot;id&quot;`
    Content string    `json:&quot;content&quot;`
    Author  Author    `json:&quot;author&quot;`
    Comment []Comment `json:&quot;comments&quot;`
&#125;

type Author struct &#123;
    Id   int    `json:&quot;id&quot;`
    Name string `json:&quot;name&quot;`
&#125;

type Comment struct &#123;
    Id      int    `json:&quot;id&quot;`
    Content string `json:&quot;content&quot;`
    Author  string `json:&quot;author&quot;`
&#125;

func main() &#123;
    // 打开json文件
    jsonFile, err := os.Open(&quot;post.json&quot;)
    if err != nil &#123;
        fmt.Println(&quot;不存在json文件！&quot;)
        return
    &#125;
    defer jsonFile.Close()
    
    // 读取json文件
    jsonData, err := ioutil.ReadAll(jsonFile)
    if err != nil &#123;
        fmt.Println(&quot;读取json文件错误！&quot;)
        return
    &#125;
    fmt.Printf(&quot;JSON文件：%s\n&quot;, jsonData)
    var post Post
    // json文件反序列化
    json.Unmarshal(jsonData, &amp;post)
    fmt.Printf(&quot;反序列化后文件的内容：%v\n&quot;,post)
&#125;
</code></pre>
<pre><code class="json">// post.json
&#123;
    &quot;id&quot;: 1,
    &quot;content&quot;: &quot;hello golang&quot;,
    &quot;author&quot;: &#123;
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;miller Fan&quot;
    &#125;,
    &quot;comments&quot;: [
      &#123;
        &quot;id&quot;: 3,
        &quot;content&quot;: &quot;Have a good night&quot;,
        &quot;author&quot;: &quot;屈原&quot;
      &#125;,
      &#123;
        &quot;id&quot;: 4,
        &quot;content&quot;: &quot;道德经&quot;,
        &quot;author&quot;: &quot;老子&quot;
      &#125;
    ]
  &#125;
</code></pre>
<h2 id="2-17-进度条"><a href="#2-17-进度条" class="headerlink" title="2.17 进度条"></a>2.17 进度条</h2><pre><code class="Golang">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

func main() &#123;
    num := 100
    for i := 0; i &lt;= num; i++ &#123;
        // 时间50秒
        time.Sleep(50 * time.Millisecond)
        h := strings.Repeat(&quot;=&quot;, i) + strings.Repeat(&quot; &quot;, num-i)
        fmt.Printf(&quot;\r%3d%%[\x1b[1;0;%dm%s\x1b[0m]&quot;, i, 30+(i%7), h)
        os.Stdout.Sync()
    &#125;
    fmt.Println(&quot;\n已完成!&quot;)
&#125;
</code></pre>
<h2 id="2-18-动态加载"><a href="#2-18-动态加载" class="headerlink" title="2.18 动态加载"></a>2.18 动态加载</h2><pre><code class="Golang">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    // 需要启动一个线程
    // 需要控制top的值
    top := true
    fmt.Println(&quot;[\033[33;1m*\033[0m] 扫描开始！&quot;)
    go func() &#123;
        for top &#123;
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;[\033[34;1m—\033[0m] 扫描中。。。\r&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;[\033[34;1m\\\033[0m] 扫描中。。。\r&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;[\033[34;1m|\033[0m] 扫描中。。。\r&quot;)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf(&quot;[\033[34;1m/\033[0m] 扫描中。。。\r&quot;)
        &#125;
        fmt.Println()
    &#125;()
    for i := 0; i &lt; 10; i++ &#123;
        time.Sleep(1000 * time.Millisecond)
    &#125;
    top = false
    fmt.Printf(&quot;\r&quot;)
    fmt.Println(&quot;\n[\033[33;1m*\033[0m] 扫描结束！&quot;)
&#125;
</code></pre>
<h2 id="2-19-汉字转拼音"><a href="#2-19-汉字转拼音" class="headerlink" title="2.19 汉字转拼音"></a>2.19 汉字转拼音</h2><pre><code class="Golang">package main

import (
    &quot;fmt&quot;

    &quot;github.com/mozillazg/go-pinyin&quot;
)

func main() &#123;
    hans := &quot;中国人&quot;

    // 默认
    a := pinyin.NewArgs()
    fmt.Println(pinyin.Pinyin(hans, a))
    // [[zhong] [guo] [ren]]

    // 包含声调
    a.Style = pinyin.Tone
    fmt.Println(pinyin.Pinyin(hans, a))
    // [[zhōng] [guó] [rén]]

    // 声调用数字表示
    a.Style = pinyin.Tone2
    fmt.Println(pinyin.Pinyin(hans, a))
    // [[zho1ng] [guo2] [re2n]]

    // 开启多音字模式
    a = pinyin.NewArgs()
    a.Heteronym = true
    fmt.Println(pinyin.Pinyin(hans, a))
    // [[zhong zhong] [guo] [ren]]
    a.Style = pinyin.Tone2
    fmt.Println(pinyin.Pinyin(hans, a))
    // [[zho1ng zho4ng] [guo2] [re2n]]

    fmt.Println(pinyin.LazyPinyin(hans, pinyin.NewArgs()))
    // [zhong guo ren]

    fmt.Println(pinyin.Convert(hans, nil))
    // [[zhong] [guo] [ren]]

    fmt.Println(pinyin.LazyConvert(hans, nil))
    // [zhong guo ren]
    
    name := &quot;&quot;
    for _, val := range pinyin.LazyConvert(hans, nil) &#123;
        name += val
    &#125;
    fmt.Println(name)
    // zhongguoren
&#125;
</code></pre>
<h2 id="2-20-获取客户端IP"><a href="#2-20-获取客户端IP" class="headerlink" title="2.20 获取客户端IP"></a>2.20 获取客户端IP</h2><pre><code class="Golang">package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
)

func getip(c *gin.Context) &#123;
    // 获取客户端真实ip地址
    reqIP := c.ClientIP()
    if reqIP == &quot;::1&quot; &#123;
        reqIP = &quot;127.0.0.1&quot;
    &#125;
    fmt.Println(&quot;\x1b[33m[*]\x1b[0m 客户端的的IP为&quot; + reqIP)
    c.String(http.StatusOK, &quot;[+] 您访问的的IP为&quot;+reqIP)
&#125;

func main() &#123;
    var port string
    flag.StringVar(&amp;port, &quot;p&quot;, &quot;8082&quot;, &quot;监听的端口&quot;)
    flag.Parse()
    fmt.Println(&quot;\x1b[32m[+]\x1b[0m 默认监听8082端口！&quot;)
    r := gin.Default()
    // 如果应用程序不在代理之后，“ForwardedByClientIP”应设置为 false，因此“X-Forwarded-For”将被忽略。
    // 如果在代理后面将其设置为true
    r.ForwardedByClientIP = true
    r.GET(&quot;/&quot;, getip)
    r.Run(&quot;:&quot; + port)
&#125;
</code></pre>
<h2 id="2-21-格式化用户输入的IP"><a href="#2-21-格式化用户输入的IP" class="headerlink" title="2.21 格式化用户输入的IP"></a>2.21 格式化用户输入的IP</h2><pre><code class="Golang">// IP的形式无非4种：逗号隔开，/和-连续的形式，以及单个IP
// 由于逗号是一个分类大方向，所以先是判断逗号的，然后根据/和-连续这两种不同形式，进行划分，分出-和/，然后/的格式单一，所以统一转换成-格式，最后转换成单个
package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;net&quot;
    &quot;regexp&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

// 处理ip
func ProcessIPs(ips string) (hostlist []string) &#123;
    // 判断是否有逗号
    if strings.Contains(ips, &quot;,&quot;) &#123;
        // 如果有逗号将其划分多个IP表
        IPList := strings.Split(ips, &quot;,&quot;)
        // 存放IP用与hosts变量一致
        var ips []string
        // 循环处理IP表
        for _, ip := range IPList &#123;
            ips = parseIP(ip)
            hostlist = append(hostlist, ips...)
        &#125;
    &#125; else &#123;
        hostlist = parseIP(ips)
    &#125;
    return RemoveDuplicate(hostlist)
&#125;

// 根据用户给出的ip形式进行分类
func parseIP(ip string) []string &#123;
    reg := regexp.MustCompile(`[a-zA-Z]+`)
    switch &#123;
    case strings.HasSuffix(ip, &quot;/8&quot;):
        // 扫描/8时，由于A段太多了，只扫网关和随机IP，避免扫描过多IP
        return parseIP8(ip)
    case strings.Contains(ip, &quot;/&quot;):
        // 解析 /24 /16等
        return parseIP2(ip)
    case reg.MatchString(ip):
        // 域名用lookup获取ip
        host, err := net.LookupHost(ip)
        if err != nil &#123;
            return nil
        &#125;
        return host
    case strings.Contains(ip, &quot;-&quot;):
        // 处理192.168.1.1-192.168.1.100或者192.168.1.1-24
        return parseIP1(ip)
    default:
        // 处理单个ip
        testIP := net.ParseIP(ip)
        if testIP == nil &#123;
            return nil
        &#125;
        return []string&#123;ip&#125;
    &#125;
&#125;

// 把 192.168.x.x/xx 转换成IP列表
func parseIP2(host string) (hosts []string) &#123;
    // 使用 net.ParseCIDR() 方法解析给定的网段，返回网段的 IP 地址和子网掩码
    // 检查给定的网段是否正确
    ipone, ipNet, err := net.ParseCIDR(host)
    if err != nil &#123;
        return
    &#125;
    // 把 192.168.x.x/xx 转换成 192.168.x.x-192.168.x.x 并转成IP列表
    hosts = parseIP1(IPRange(ipone.String(), ipNet))
    return
&#125;

// 解析ip段: 192.168.111.1-255，192.168.111.1-192.168.112.255
func parseIP1(ip string) []string &#123;
    // 如果有逗号将其划分多个
    IPRangelist := strings.Split(ip, &quot;-&quot;)
    // 确认该IP格式是否为正确IP
    testIP := net.ParseIP(IPRangelist[0])
    // 创建一个存储所有IP列表
    var allIP []string
    // 通过len函数来确认IPRangelist[1]是192.168.1.255形式还是数字形式
    if len(IPRangelist[1]) &lt; 4 &#123;
        // 处理数字形式
        // 将字符串转成数字
        Range, err := strconv.Atoi(IPRangelist[1])
        // 判断合理性
        if testIP == nil || Range &gt; 255 || err != nil &#123;
            return nil
        &#125;
        // 分离IP
        SplitIP := strings.Split(IPRangelist[0], &quot;.&quot;)
        // 转换为数字
        ip1, err1 := strconv.Atoi(SplitIP[3])
        // 拼接
        PrefixIP := SplitIP[0] + &quot;.&quot; + SplitIP[1] + &quot;.&quot; + SplitIP[2]
        // 判断合理性
        if ip1 &gt; Range || err1 != nil &#123;
            return nil
        &#125;
        // 循环拼接IP
        for i := ip1; i &lt;= Range; i++ &#123;
            allIP = append(allIP, PrefixIP+&quot;.&quot;+strconv.Itoa(i))
        &#125;
    &#125; else &#123;
        // 处理192.168.1.255形式
        // 分离IP
        SplitIP1 := strings.Split(IPRangelist[0], &quot;.&quot;)
        SplitIP2 := strings.Split(IPRangelist[1], &quot;.&quot;)
        // 判断合理性
        if len(SplitIP1) != 4 || len(SplitIP2) != 4 &#123;
            return nil
        &#125;
        // 用于存放起始IP和结束IP列表
        start, end := [4]int&#123;&#125;, [4]int&#123;&#125;
        // 循环读取4段IP
        for i := 0; i &lt; 4; i++ &#123;
            // 转换为数字
            ip1, err1 := strconv.Atoi(SplitIP1[i])
            ip2, err2 := strconv.Atoi(SplitIP2[i])
            // 判断合理性
            if ip1 &gt; ip2 || err1 != nil || err2 != nil &#123;
                return nil
            &#125;
            // 添加到起始IP和结束IP列表
            start[i], end[i] = ip1, ip2
        &#125;
        // 通过移位运算，将地址改为数字的形式
        startNum := start[0]&lt;&lt;24 | start[1]&lt;&lt;16 | start[2]&lt;&lt;8 | start[3]
        endNum := end[0]&lt;&lt;24 | end[1]&lt;&lt;16 | end[2]&lt;&lt;8 | end[3]
        // 通过循环将数字转成地址
        for num := startNum; num &lt;= endNum; num++ &#123;
            ip := strconv.Itoa((num&gt;&gt;24)&amp;0xff) + &quot;.&quot; + strconv.Itoa((num&gt;&gt;16)&amp;0xff) + &quot;.&quot; + strconv.Itoa((num&gt;&gt;8)&amp;0xff) + &quot;.&quot; + strconv.Itoa((num)&amp;0xff)
            allIP = append(allIP, ip)
        &#125;
    &#125;
    return allIP
&#125;

// 获取把 192.168.x.x/xx 转换成 192.168.x.x-192.168.x.x的起始IP、结束IP
func IPRange(start string, c *net.IPNet) string &#123;
    // 16进制子网掩码
    mask := c.Mask
    // 创建一个net.ip类型
    bcst := make(net.IP, len(c.IP))
    // 将dreams值给bcst
    copy(bcst, c.IP)
    // 获取结束IP
    for i := len(mask) - 1; i &gt;= 0; i-- &#123;
        bcst[i] = c.IP[i] | ^mask[i]
    &#125;
    end := bcst.String()
    // 返回用-表示的ip段,192.168.1.1-192.168.255.255
    return fmt.Sprintf(&quot;%s-%s&quot;, start, end)
&#125;

// 处理B段IP
func parseIP8(ip string) []string &#123;
    // 去掉最后的/8
    realIP := ip[:len(ip)-2]
    // net.ParseIP 这个方法用来检查 ip 地址是否正确，如果不正确，该方法返回 nil
    testIP := net.ParseIP(realIP)
    // 判断该IP是否为正常IP
    if testIP == nil &#123;
        return nil
    &#125;
    // 获取IP的头部
    IP8head := strings.Split(ip, &quot;.&quot;)[0]
    // 存放B段IP
    var allIP []string
    // 构造B段的随机IP表
    for a := 0; a &lt;= 255; a++ &#123;
        for b := 0; b &lt;= 255; b++ &#123;
            // 一般情况下网关为1或者254
            allIP = append(allIP, fmt.Sprintf(&quot;%s.%d.%d.%d&quot;, IP8head, a, b, 1))
            allIP = append(allIP, fmt.Sprintf(&quot;%s.%d.%d.%d&quot;, IP8head, a, b, RandInt(2, 80)))
            allIP = append(allIP, fmt.Sprintf(&quot;%s.%d.%d.%d&quot;, IP8head, a, b, RandInt(81, 170)))
            allIP = append(allIP, fmt.Sprintf(&quot;%s.%d.%d.%d&quot;, IP8head, a, b, RandInt(171, 253)))
            allIP = append(allIP, fmt.Sprintf(&quot;%s.%d.%d.%d&quot;, IP8head, a, b, 254))
        &#125;
    &#125;
    return allIP
&#125;

// 去重函数
func RemoveDuplicate(old []string) []string &#123;
    result := []string&#123;&#125;
    temp := map[string]struct&#123;&#125;&#123;&#125;
    for _, item := range old &#123;
        if _, ok := temp[item]; !ok &#123;
            temp[item] = struct&#123;&#125;&#123;&#125;
            result = append(result, item)
        &#125;
    &#125;
    return result
&#125;

// 随机数
func RandInt(min, max int) int &#123;
    if min &gt;= max || min == 0 || max == 0 &#123;
        return max
    &#125;
    return rand.Intn(max-min) + min
&#125;

// 主函数
func main() &#123;
    // 定义命令行参数方式
    var IPs string
    flag.StringVar(&amp;IPs, &quot;ip&quot;, &quot;&quot;, &quot;ip地址&quot;)
    // 解析命令行参数
    flag.Parse()
    // 判断是否输入IP
    if IPs == &quot;&quot; &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m] 没有输入IP！&quot;)
        flag.Usage()
        return
    &#125;
    // 对用户输入的IP参数进行格式化处理
    hosts := ProcessIPs(IPs)
    for i, val := range hosts &#123;
        fmt.Println(i, val)
    &#125;
&#125;
</code></pre>
<h2 id="2-22-文件写入"><a href="#2-22-文件写入" class="headerlink" title="2.22 文件写入"></a>2.22 文件写入</h2><pre><code class="Golang">// 文件写入
func WriteFile(result string, filename string) &#123;
    var text = []byte(result + &quot;\n&quot;)
    f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
    if err != nil &#123;
        fmt.Printf(&quot;[\033[31;1m-\033[0m] 打开文件 %s 失败, %v\n&quot;, filename, err)
        return
    &#125;
    _, err = f.Write(text)
    f.Close()
    if err != nil &#123;
        fmt.Printf(&quot;[\033[31;1m-\033[0m] 写入文件 %s 失败, %v\n&quot;, filename, err)
    &#125;
&#125;
</code></pre>
<h2 id="2-23-判断字符串是否在列表中"><a href="#2-23-判断字符串是否在列表中" class="headerlink" title="2.23 判断字符串是否在列表中"></a>2.23 判断字符串是否在列表中</h2><pre><code class="Golang">// 判断字符串是否在列表中
func strinlist(str string, str_array []string) bool &#123;
    for _, s := range str_array&#123;
       if str == s&#123;
           return true
       &#125;
   &#125;
   return false
&#125;
</code></pre>
<h2 id="2-24-读取json文件内容并设置为结构体"><a href="#2-24-读取json文件内容并设置为结构体" class="headerlink" title="2.24 读取json文件内容并设置为结构体"></a>2.24 读取json文件内容并设置为结构体</h2><pre><code class="Golang">// 读取json文件
func Readjsonfile(filename string) ([]jsonType, error) &#123;
    // 设置json文件列表
    // jsonType是自定义的结构体，用来反序列化的
    var jsonlist []jsonType
    data, err := ioutil.ReadFile(filename)
    if err != nil &#123;
        return nil, err
    &#125;
    err = json.Unmarshal(data, &amp;jsonlist)
    if err != nil &#123;
        return nil, err
    &#125;
    return jsonlist, nil
&#125;
</code></pre>
<h2 id="2-25-结构体转换为json文件"><a href="#2-25-结构体转换为json文件" class="headerlink" title="2.25 结构体转换为json文件"></a>2.25 结构体转换为json文件</h2><pre><code class="Golang">// 结构体转换为json
func Switchjson(date []AvType) error &#123;
    jsonByteData, err := json.Marshal(date)
    if err != nil &#123;
        return err
    &#125;
    // 这里使用了前面 2.22 文件写入方法
    WriteFile(string(jsonByteData), &quot;demo.json&quot;)
    return nil
&#125;
</code></pre>
<h2 id="2-26-格式化用户输入的端口"><a href="#2-26-格式化用户输入的端口" class="headerlink" title="2.26 格式化用户输入的端口"></a>2.26 格式化用户输入的端口</h2><pre><code class="Golang">// 端口格式化与IP格式化差不多
package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

// 格式化处理端口
func ParsePort(ports string) (scanPorts []int) &#123;
    // 判断端口是否为空
    if ports == &quot;&quot; &#123;
        return
    &#125;
    // 根据逗号切割端口
    slices := strings.Split(ports, &quot;,&quot;)
    // 循环获取端口
    for _, port := range slices &#123;
        // 去除空白符
        port = strings.TrimSpace(port)
        // 判断去除后空白符的端口是否正确
        if port == &quot;&quot; &#123;
            continue
        &#125;
        upper := port
        // 判断端口是否有-这样连续的
        if strings.Contains(port, &quot;-&quot;) &#123;
            // 分离端口
            ranges := strings.Split(port, &quot;-&quot;)
            // 判断分离出的端口是否多个
            if len(ranges) &lt; 2 &#123;
                continue
            &#125;
            // 设置端口范围的开始和结束
            startPort, _ := strconv.Atoi(ranges[0])
            endPort, _ := strconv.Atoi(ranges[1])
            if startPort &lt; endPort &#123;
                port = ranges[0]
                upper = ranges[1]
            &#125; else &#123;
                port = ranges[1]
                upper = ranges[0]
            &#125;
        &#125;
        // 赋值
        start, _ := strconv.Atoi(port)
        end, _ := strconv.Atoi(upper)
        // 将端口赋值给scanPorts
        for i := start; i &lt;= end; i++ &#123;
            scanPorts = append(scanPorts, i)
        &#125;
    &#125;
    // 端口去重
    scanPorts = removeDuplicate(scanPorts)
    return scanPorts
&#125;

// 去重函数
func removeDuplicate(old []int) []int &#123;
    result := []int&#123;&#125;
    temp := map[int]struct&#123;&#125;&#123;&#125;
    for _, item := range old &#123;
        if _, ok := temp[item]; !ok &#123;
            temp[item] = struct&#123;&#125;&#123;&#125;
            result = append(result, item)
        &#125;
    &#125;
    return result
&#125;

// 主函数
func main() &#123;
    // 定义命令行参数方式
    var Ports string
    flag.StringVar(&amp;Ports, &quot;p&quot;, &quot;&quot;, &quot;端口&quot;)
    // 解析命令行参数
    flag.Parse()
    // 判断是否输入Port
    if Ports == &quot;&quot; &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m] 没有输入Ports！&quot;)
        flag.Usage()
        return
    &#125;
    // 对用户输入的IP参数进行格式化处理
    Portslist := ParsePort(Ports)
    for i, val := range Portslist &#123;
        fmt.Println(i, val)
    &#125;
&#125;
</code></pre>
<h2 id="2-27-快速判断文件类型"><a href="#2-27-快速判断文件类型" class="headerlink" title="2.27 快速判断文件类型"></a>2.27 快速判断文件类型</h2><p>在正常情况下，我们需要判断文件类型有两种方法：</p>
<ul>
<li>根据文件的扩展名来判断，比如<code>.jpg</code>表示<code>JPEG</code>图像，<code>.mp3</code>表示<code>MP3</code>音频等<ul>
<li>优点：简单快速</li>
<li>缺点：容易被伪造或者缺失</li>
</ul>
</li>
<li>根据文件内容的特征来判断，比如<code>JPEG</code>图像的前几个字节是<code>FF D8 FF</code>，<code>MP3</code>音频的前几个字节是<code>ID3</code>等。<ul>
<li>优点：准确可靠</li>
<li>缺点：需要读取文件内容并进行分析</li>
</ul>
</li>
</ul>
<p>而在<code>Go</code>语言的标准库<code>net/http</code>包中提供了一个简单的判断文件类型的方法<code>DetectContentType()</code>，该方法是读取文件内容的前<code>512</code>个字节内容，返回一个<code>MIME</code>类型字符串。它使用了<code>mimesniff</code>算法，根据一组预定义的规则来匹配文件内容的特征和对应的<code>MIME</code>类型。这个方法既不依赖于文件扩展名，也不需要完整地读取文件内容，因此既快速又准确。同时我们可以使用<code>mime.ExtensionsByType</code>获取该类型可能的后缀名：</p>
<pre><code class="Golang">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;mime&quot;
    &quot;net/http&quot;
    &quot;os&quot;
)

// 处理错误方法
func HandlingErrors(err error, funname string) &#123;
    if err != nil &#123;
        fmt.Println(&quot;[\033[31;1m-\033[0m] &quot;, funname, &quot;Error：&quot;, err)
        log.Panic(err)
    &#125;
&#125;
func main() &#123;
    // 打开一个 MP3 文件
    file, err := os.Open(&quot;a.jpg&quot;)
    if err != nil &#123;
        fmt.Println(err)
        return
    &#125;
    // 关闭文件
    defer file.Close()

    // 读取文件的前 512 个字节到一个缓冲区
    buffer := make([]byte, 512)
    n, err := file.Read(buffer)
    if err != nil &#123;
        HandlingErrors(err, &quot;file.Read&quot;)
    &#125;

    // 调用 http.DetectContentType 方法判断文件类型，并传入了缓冲区中的数据，这个方法会返回一个字符串表示文件的 MIME 类型
    // 实际上，如果字节数超过 512，该函数也只会使用前 512 个字节
    contentType := http.DetectContentType(buffer[:n])
    // 返回文件类型可能的文件后缀名
    ext, err := mime.ExtensionsByType(contentType)
    if err != nil &#123;
        HandlingErrors(err, &quot;mime.ExtensionsByType&quot;)
    &#125;
    // 输出文件类型
    fmt.Println(&quot;[\033[0;38;5;214m!\033[0m] 文件类型为：&quot;, contentType)
    // 输出文件类型可能的文件后缀名
    fmt.Println(&quot;[\033[0;38;5;214m!\033[0m]&quot;, contentType, &quot;类型可能的后缀名：&quot;, ext)
&#125;
</code></pre>
<h2 id="2-28-搭建http文件下载服务"><a href="#2-28-搭建http文件下载服务" class="headerlink" title="2.28 搭建http文件下载服务"></a>2.28 搭建http文件下载服务</h2><pre><code class="Golang">package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;io/fs&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;strconv&quot;
)

// 获取文件信息
func getfile() ([]fs.FileInfo, error) &#123;
    directory := &quot;./&quot;
    files, err := os.Open(directory)
    if err != nil &#123;
        fmt.Println(&quot;打开目录时出错:&quot;, err)
        return nil, err
    &#125;
    defer files.Close()

    fileInfos, err := files.Readdir(-1)
    if err != nil &#123;
        fmt.Println(&quot;读取目录时出错:&quot;, err)
        return nil, err
    &#125;
    return fileInfos, nil
&#125;

// 显示首页
func index(rw http.ResponseWriter, r *http.Request) &#123;
    files, err := getfile()
    if err != nil &#123;
        fmt.Fprintln(rw, err)
    &#125;
    html := &quot;&quot;
    for _, val := range files &#123;
        html = html + &quot;&lt;a href=&#39;download?filename=&quot; + val.Name() + &quot;&#39;&gt;&quot; + val.Name() + &quot;&lt;/a&gt;&lt;/br&gt;&quot;
    &#125;
    fmt.Fprintln(rw, html)

&#125;

// 下载功能
func download(rw http.ResponseWriter, r *http.Request) &#123;
    //获取请求参数
    fn := r.FormValue(&quot;filename&quot;)
    //设置响应头
    header := rw.Header()
    header.Add(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;)
    header.Add(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+fn)
    //使用ioutil包读取文件
    b, _ := ioutil.ReadFile(fn)
    //写入到响应流中
    rw.Write(b)
&#125;

func main() &#123;
    // 设置端口
    var port int
    flag.IntVar(&amp;port, &quot;p&quot;, 9090, &quot;自定义端口&quot;)
    // 解析命令行参数
    flag.Parse()
    if port &lt;= 0 || port &gt; 65535 &#123;
        fmt.Printf(&quot;[x] 该端口不合规！\n&quot;)
        return
    &#125;
    fmt.Println(&quot;[!] 服务端口为：&quot; + strconv.Itoa(port))
    http.HandleFunc(&quot;/&quot;, index)
    http.HandleFunc(&quot;/download&quot;, download)
    err := http.ListenAndServe(&quot;:&quot;+strconv.Itoa(port), nil)
    if err != nil &#123;
        fmt.Printf(&quot;[x] http服务器失败，err:%v\n&quot;, err)
        return
    &#125;
&#125;
</code></pre>
<h2 id="2-29-判断为空方法"><a href="#2-29-判断为空方法" class="headerlink" title="2.29 判断为空方法"></a>2.29 判断为空方法</h2><pre><code class="Golang">func main() &#123;
    // 判断字符串为空
    str := &quot;&quot;
    if str != &quot;&quot; &#123;
        fmt.Println(&quot;字符串为空&quot;)
    &#125;

    // 判断数组或者切片为空
    List := []string&#123;&#125;
    if len(List) != 0 &#123;
        fmt.Println(&quot;数组为空&quot;)
    &#125;

    // 判断map为空
    Map := make(map[string]int)
    if len(Map) != 0 &#123;
        fmt.Println(&quot;数组为空&quot;)
    &#125;
&#125;
</code></pre>
<h2 id="2-30-以行的方式读取文件内的字符串"><a href="#2-30-以行的方式读取文件内的字符串" class="headerlink" title="2.30 以行的方式读取文件内的字符串"></a>2.30 以行的方式读取文件内的字符串</h2><pre><code class="golang">// 读取文件并以[]string形式返回内容
func ReadingLines(filename string) []string &#123;
    // 设置结果变量
    var result []string
    // 打开文件
    file, err := os.Open(filename)
    if err != nil &#123;
        return result
    &#125;
    defer file.Close()
    // 开始读取文件
    scanner := bufio.NewScanner(file)
    // 循环读取
    for scanner.Scan() &#123;
        val := scanner.Text()
        // 判断是否为空
        if val == &quot;&quot; &#123;
            continue
        &#125;
        // 拼接
        result = append(result, val)
    &#125;
    // 判断是否存在终止错误
    if err := scanner.Err(); err != nil &#123;
        return result
    &#125;
    return result
&#125;
</code></pre>

        </div>
        
        
        <div id="comment">
            <div id="giscus-container" class="giscus"></div>
        </div>
        
    </div>
    
    <div id="article-card">
        <div id="card-style">
    <div id="card-div" class="card-cls">
        <div class="avatar">
            <img src="/images/f6e2b991f74bfd7b88c3ab1a3d513b94.jpg" alt="avatar" />
        </div>
        <div class="name">小C&amp;天天</div>
        <div class="description">
            <p>修学储能 先博后渊</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/A7cc">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.qq.com/">
                    <i class="fa-brands fa-qq fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.weibo.com/">
                    <i class="fa-brands fa-weibo fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://google.com/">
                    <i class="fa-brands fa-google fa-fw"></i>
                </a>
            </span>
            
        </div>
        
        
        <div class="friend-links">
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="http://www.wgs6km.top/">kyrieee</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://tonyd0g.gitee.io/">tonyd0g</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://ruyueattention.github.io/">ruyueattention</a>
            </span>
            
        </div>
        
    </div>
    
    <!-- <br /> -->
    <!-- 目录 -->
    <!-- 
    <div id="card-div">
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B9-%E8%AF%B4%E6%98%8E"><span class="toc-text">壹 说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%B0-%E5%B0%8F%E8%84%9A%E6%9C%AC"><span class="toc-text">贰 小脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 处理错误方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%A0%87%E5%BF%97"><span class="toc-text">2.2 标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%87%E7%89%87%E5%8E%BB%E9%87%8D"><span class="toc-text">2.3 切片去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%8E%92%E9%99%A4%E5%86%85%E7%BD%91IP"><span class="toc-text">2.4 排除内网IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-IP%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.5 IP的正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%BB%88%E7%AB%AF%E9%A2%9C%E8%89%B2"><span class="toc-text">2.6 终端颜色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%BAint%E5%88%87%E7%89%87%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">2.7 字符串类型的端口转换为int切片的端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%B0%86int%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.8 将int转换为字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Ping%E9%80%9A%E4%B8%BB%E6%9C%BA%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.9 Ping通主机以及判断操作系统类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E5%AE%9E%E7%8E%B0SHA256%E7%94%9F%E6%88%90%E6%95%A3%E5%88%97%E5%80%BC"><span class="toc-text">2.10 实现SHA256生成散列值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6"><span class="toc-text">2.11 获取当前目录下所有文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">2.12 生成随机数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-Base64%E7%BC%96%E7%A0%81"><span class="toc-text">2.13 Base64编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-text">2.14 判断字符串是否包含某个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="toc-text">2.15 字符串反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-%E8%AF%BB%E5%8F%96json%E6%96%87%E4%BB%B6"><span class="toc-text">2.16 读取json文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-text">2.17 进度条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-18-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.18 动态加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-19-%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8B%BC%E9%9F%B3"><span class="toc-text">2.19 汉字转拼音</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-20-%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP"><span class="toc-text">2.20 获取客户端IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-21-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84IP"><span class="toc-text">2.21 格式化用户输入的IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-22-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">2.22 文件写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-23-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%AD"><span class="toc-text">2.23 判断字符串是否在列表中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-24-%E8%AF%BB%E5%8F%96json%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.24 读取json文件内容并设置为结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-25-%E7%BB%93%E6%9E%84%E4%BD%93%E8%BD%AC%E6%8D%A2%E4%B8%BAjson%E6%96%87%E4%BB%B6"><span class="toc-text">2.25 结构体转换为json文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-26-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">2.26 格式化用户输入的端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-27-%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.27 快速判断文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-28-%E6%90%AD%E5%BB%BAhttp%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1"><span class="toc-text">2.28 搭建http文件下载服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29-%E5%88%A4%E6%96%AD%E4%B8%BA%E7%A9%BA%E6%96%B9%E6%B3%95"><span class="toc-text">2.29 判断为空方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-30-%E4%BB%A5%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.30 以行的方式读取文件内的字符串</span></a></li></ol></li></ol>
        </div>    
    </div>
     -->
</div>

<div id="card-style-fun">
    
    <br />
    <!-- 今日诗句 -->
    <div id="card-div">
        <div class="good-sentence">
            <div class="toolio">
                <div class="circle"><span class="red"></span></div>
                <div class="circle"><span class="yellow"></span></div>
                <div class="circle"><span class="green"></span></div>
                <div class="circle"><span class="text">今日诗句</span></div>
            </div>
            <div class="sentence">
                <div id="sentenceid" onload="getsentence();"></div>
            </div>
        </div>
    </div>
    <br />
    <!-- 日期信息 -->
    <div id="card-div">
        <img src="//api.vvhan.com/api/ipCard?tip=A7cc" width="300" height="180">
    </div>
    
</div>



    </div>
    
</div>
                <!-- 页脚 -->
                <footer id="footer">
    <div id="footer-wrap">
        <div>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
            <script>
                var now = new Date(); 
                function createtime() { 
                    var grt= new Date("07/10/2022 00:00:00");
                    now.setTime(now.getTime()+250); 
                    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                    document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
                } 
            setInterval("createtime()",250);
            </script>
        </div>
        <div>
            &copy;
            2022 - 2023 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            &commat;小C&amp;天天
        </div>
        <div>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX</a> 
        </div>
        
    </div>
</footer>

            </div>
            <!-- 简单的点击图片放大缩小的预览 -->
            
            <div name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </div>
            
        </div>
        <!-- 看板娘 -->
        
        <div id="L2dCanvas"></div>
        <script src="/js/lib/live2d.min.js"></script>
        <!-- 设置随机模板 -->
        
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "bisimai_2",
                mobile: true,
            });
        </script>
        
        <!-- 诗句 -->
        
        <script>
            // // 每隔10分钟执行一次getsentence这个函数
            window.setInterval(getsentence, 100*60*5);
            function getsentence() {
                // 这里没有考虑IE浏览器，如果需要择if判断加
                var xhr = new XMLHttpRequest();  
                xhr.open('GET', "https://zj.v.api.aa1.cn/api/wenan-shici/?type=json",true);
                xhr.send(JSON.stringify(null));
                xhr.onreadystatechange = function () {
                    if (xhr.status === 200 && xhr.readyState === 4) {
                        //js处理数据
                        // xhr.responseText.match(/content":(".+?")/g)
                        getdata = JSON.parse(xhr.responseText).msg;
                    }else{
                        getdata = "长风破浪会有时，直挂云帆济沧海。——李白《行路难》";
                    }
                    document.getElementById("sentenceid").innerHTML = getdata;
                }
            }
            window.onload = getsentence;
        </script>
        
        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
        <!-- 流星背景特效 -->
        
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/meteorbackground.js"></script>
        
        <script src="/js/main.js"></script>
    </body>
</html>
