
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="utf-8" />
        <title>Python的核心知识（七）——面向对象 | 小C♥天天</title>
        <meta name="author" content="小C&天天" />
        <meta name="description" content="^v^" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/icon.jpg" />
        <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<!-- 兼容不同版本的浏览器 -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<!-- 高亮代码 -->
<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"/>
<script src="/js/lib/highlight.js"></script>


<!-- 使用 KaTeX 渲染数学公式 -->
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<!-- 简单的点击图片放大缩小的预览 -->
<script src="/js/lib/preview.js"></script>


<!-- 看板娘 -->
<script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>


<!-- 侧边小功能-->



<!-- 评论设置 -->

<script
    src="https://giscus.app/client.js"
    data-repo="A7cc/giscus-comments"
    data-repo-id="R_kgDOKKSvfw"
    data-category="Announcements"
    data-category-id="DIC_kwDOKKSvf84CYyp2"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>



<script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="layout">
            <!-- 页面加载 -->
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>正在加载</p>
                        <img src="/images/afde9fa65a5742a90b51d6e1211e841e.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/tools">
            <i class="fa-solid fa-tools fa-fw"></i>
            <span>&ensp;工具</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
                <a href="/tools">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tools fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">工具</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div id="article-posts-wrap" true ref="homePostsWrap">
    <div class="article">
        <div>
            <h1>Python的核心知识（七）——面向对象</h1>
        </div>
        <div class="info">
            <span class="date">
                <span class="icon">
                    <i class="fa-solid fa-calendar fa-fw"></i>
                </span>
                2023/3/14
            </span>
            
            <span class="category">
                <a href="/categories/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">
                    <span class="icon">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </span>
                    Python基础教程
                </a>
            </span>
            
            
            <span class="tags">
                <span class="icon">
                    <i class="fa-solid fa-tags fa-fw"></i>
                </span>
                
                
                <span class="tag">
                    
                    <a href="/tags/Python/" style="color: #03a9f4">Python</a>
                </span>
                
                <span class="tag">
                    
                    <a href="/tags/%E5%BC%80%E5%8F%91/" style="color: #ffa2c4">开发</a>
                </span>
                
            </span>
            
        </div>
        
        <div class="content" v-pre>
            <h1 id="一、WHY-学习面向对象？"><a href="#一、WHY-学习面向对象？" class="headerlink" title="一、WHY 学习面向对象？"></a>一、WHY 学习面向对象？</h1><p>假设现在有一个场景是这样的，我们要编写一个游戏，里面有主角，NPC，怪物等等这些模型，那么如果我们不学面向对象的话，我们就需要一个一个的编写它们的属性及动作，一般情况下，一个大型的游戏比如LOL（这游戏是真的火，都好几年了还没被干掉）里面的英雄，小兵，大龙，有好上百个模型吧。我们不可能一个一个的写，那代码量就不是一两个g那么大了（其实这就是面向过程的思想，POP）！仔细观察会发现它们这些模型都有相同的属性和动作，比如：都有生命值，魔法值等属性，攻击等动作，所以编程语言开发者们就在想了，有没有一个东西把它们共同的属性、动作封装起来，这时候类概念应运而生了，就是我们这篇文章的主体对象，而这种思想就是面向对象（OOP）！</p>
<span id="more"></span>

<p><strong>那什么是面向对象编程呢？</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089?fr=aladdin">度娘一下</a>：面向对象(Object Oriented)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。</p>
<p>巴拉巴拉一堆，感觉懵懵懂懂，个人的理解就是，一种思想，相对于面向过程的一种思想。这是我个人对关于面向对象与面向过程的区别的理解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41734243/article/details/104263828">链接在此</a></p>
<h1 id="二、类和对象"><a href="#二、类和对象" class="headerlink" title="二、类和对象"></a>二、类和对象</h1><p>类和对象是面向对象编程里面的两个非常重要的概念。它们的关系嘛，嗯~，如果是说类是一张汽车的图纸，那么一辆根据这个图纸制造出来的汽车就是一个对象！</p>
<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><p>类啥是类？用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。就可以理解为之前我们学习的函数，是一种有自治系统的函数，有自己的属性方法等等。类也是虚的，和函数一样，只有当它被实例化时才是计算机要运行的代码块，一个稿纸。</p>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h2><p>对象又是啥？女朋友？男朋友？nonono，编程中的对象可不男女朋友万能多了，它可以帮你制造一个男朋友或者女朋友，厉害吧！那啥是对象？对象就是类的实例化，上面说了类是虚的，纸上谈兵，而对象是实，招兵买马。和函数一样，函数是虚的，调用函数是实的。</p>
<h1 id="三、类和对象"><a href="#三、类和对象" class="headerlink" title="三、类和对象"></a>三、类和对象</h1><p>那问题来了，知道它们的重要性，就得学会用它们了吧！那怎么用？听我慢慢道来！</p>
<p>首先这里推荐一个适合工作用的Python编程工具（看个人吧！想用就用，毕竟好东西要一起分享嘛！）：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/pycharm/download/">pycharm</a>	</p>
<p><strong>注意：像这种官方工具，尽量使用专业版，首先同为在IT行业的我们应该尊重编写pycharm的团队成果，其次在使用社区版的软件是不全面，这时候我们就会想用盗版破解软件，如果使用盗版软件，在以后的工作中就会涉及到版权的法律问题，那就不是一两百可以解决的问题了。</strong></p>
<h2 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1.类的定义"></a>1.类的定义</h2><p><strong>格式：</strong></p>
<blockquote>
<p>class 类的名字:<br> …类的属性 &#x3D; 属性值<br> …类的方法(self, [参数]):<br> … …方法体</p>
</blockquote>
<p>类的属性，在Python中类的属性的定义与变量定义一样，记得赋值<br>类的方法，在Python中类的方法的定义与普通的函数定义方法一样，记得加self变量<br><strong>代码</strong></p>
<pre><code class="python">class Str:
    #一般Python属性的定义是直接赋值的，不像C++等编程语言是不可以赋值的
    name = &quot;cc&quot;
    age = 18
    #类的方法定义在参数表里，必须加上一个变量，一般情况Python编程者普遍使用self为变量名
    #self就是相对于C++的this指针，由于类是模型，而对象是由类实例化产生的，所以为了区分不同的对象，我们通过引进self变量区别
    #self变量的意思是将实例化后的对象的名字传递给self，而这种传递是在类里面的，调用方法时不需要传递
    #说白了，self就是一种标记实例化对象的全局变量，而方法里面的变量是局部变量
    #__init__魔法方法就是对类的初始化，在定义时本身就有的，现在是把它进行覆盖（后面会写），是不需要在实例化时调用的
    #通常称__init__为构造方法
    #其实类里面还有很多类似的方法，自行探索
    #self.name是对类内部属性的访问或者复制
    def __init__(self, Name):
        self.name = Name
    def S_print(self):
        print(&quot;Name is &#123;&#125;, Age is &#123;&#125;&quot;.format(self.name, self.age))
</code></pre>
<p><strong>类定义是虚的，不会在程序中显示！</strong></p>
<h2 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h2><p><strong>格式：</strong></p>
<blockquote>
<p>实例化对象名 &#x3D; 类名([参数])<br>实例化对象名.类属性名<br>实例化对象名.类方法名</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">class Str:
    name = &quot;cc&quot;
    age = 18
    def __init__(self, Name):
        self.name = Name
    def S_print(self):
        print(&quot;Name is &#123;&#125;, Age is &#123;&#125;&quot;.format(self.name, self.age))

s = Str(&quot;qq&quot;)	#括号里的参数是当__init__魔法方法的列表里面有除了self属性外，还有其他属性的话，才添加的
print(s.name)
s.S_print()
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/20200302182021315.png" alt="在这里插入图片描述"></p>
<h2 id="3-类中的方法"><a href="#3-类中的方法" class="headerlink" title="3.类中的方法"></a>3.类中的方法</h2><h3 id="a-内置方法"><a href="#a-内置方法" class="headerlink" title="a.内置方法"></a>a.内置方法</h3><p>Python 创建任何一个类的时候，都会包含一些内置的方法，主要包括如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__init__</code></td>
<td>构造函数，在生成对象时调用</td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数，释放对象时使用</td>
</tr>
<tr>
<td><code>__repr__</code></td>
<td>打印，转换</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>按照索引赋值</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>按照索引获取值</td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>获得长度</td>
</tr>
<tr>
<td><code>__cmp__</code></td>
<td>比较运算</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>加运算</td>
</tr>
<tr>
<td><code>__sub__</code></td>
<td>减运算</td>
</tr>
<tr>
<td><code>__mul__</code></td>
<td>乘运算</td>
</tr>
<tr>
<td><code>__div__</code></td>
<td>除运算</td>
</tr>
<tr>
<td><code>__mod__</code></td>
<td>求余运算</td>
</tr>
<tr>
<td><code>__pow__</code></td>
<td>乘方</td>
</tr>
</tbody></table>
<h3 id="b-自定义方法"><a href="#b-自定义方法" class="headerlink" title="b.自定义方法"></a>b.自定义方法</h3><p>Python 有三种常见的方法，分别为：实例方法、类方法、静态方法，这三种方法都定义在类中。<br><strong>类方法</strong><br>类方法是将类本身作为对象进行操作的方法。<br>定义与使用</p>
<pre><code class="python">&#39;&#39;&#39;
类方法（可调类变量、可被实例调用、可被类调用）
1、类方法通过@classmethod装饰器实现，只能访问类变量，不能访问实例变量；
2、通过cls参数传递当前类对象，不需要实例化。
&#39;&#39;&#39;
class Car(object):
    name = &#39;BMW&#39;
    def __init__(self, name):
        self.name = name
    @classmethod
    def run(cls,speed):
        print(cls.name,speed,&#39;行驶&#39;)
# 访问方式1
c = Car(&quot;宝马&quot;)
c.run(&quot;100迈&quot;)
# 访问方式2
Car.run(&quot;100迈&quot;)
</code></pre>
<p><strong>静态方法</strong><br>静态方法是类中的函数，不需要实例。</p>
<p>定义与使用</p>
<pre><code class="python">&#39;&#39;&#39;
静态方法（可调类变量、可被实例调用、可被类调用）
1、用 @staticmethod 装饰的不带 self 参数的方法；
2、静态方法名义上归类管理，实际中在静态方法中无法访问类和实例中的任何属性；
3、调用时并不需要传递类或实例。
&#39;&#39;&#39;
class Car(object):
    name = &#39;BMW&#39;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def run(speed):
        print(Car.name,speed,&#39;行驶&#39;)
        
# 访问方式1
c = Car(&quot;宝马&quot;)
c.run(&quot;100迈&quot;)
# 访问方式2
Car.run(&quot;100迈&quot;)
</code></pre>
<p><strong>实例方法</strong><br>实例方法就是类的实例能够使用的方法。</p>
<p>定义与使用</p>
<pre><code class="python">&#39;&#39;&#39;
实例方法（可调类变量、可调实例变量、可被实例调用）
第一个参数强制为实例对象 self。
&#39;&#39;&#39;
class Car(object):
    name = &#39;BMW&#39;
    def __init__(self, name):
        self.name = name
    def run(self,speed):
        print(self.name,speed,&#39;行驶&#39;)

# 访问
c = Car(&quot;宝马&quot;)
c.run(&quot;100迈&quot;)
</code></pre>
<h1 id="四、面向对象三大特征"><a href="#四、面向对象三大特征" class="headerlink" title="四、面向对象三大特征"></a>四、面向对象三大特征</h1><p>Python之所以号称面向对象编程语言，是因为具有面向对象编程特有的三个特征：封装、继承、多态。</p>
<p>类对象正是因为有了这三大法宝才变得如此这般之厉害！</p>
<h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><p>封装顾名思义就是打包的意思，就是将类里面的属性和方法打包起来，放在类里面成为一个整体，这样属性和方法可以私有化了，并且提供了公共的方法去访问和赋值类的属性。</p>
<p>通过对类属性的封装使得类属性更加稳定和安全，同时通过属性私有化，还必须提供<code>setter</code>（设置方法）和<code>getter</code>（获取方法）	两种方法来让外界访问和修改属性。</p>
<p>在Python中想要私有化类中的属性和方法只要在属性和方法前面添加两个下划线<code>__</code>就可以了（例如：<code>__name</code>），而单下划线<code>_</code>也是一种私有的（例如：<code>_name</code>），但是这种下划线属于口头私有，即意思是虽然可以被访问，但是请把其视为私有变量，不要随意访问（好坑）。</p>
<p>在Python中可以通过对象名.类属性名&#x2F;方法名进行访问属性和调用方法。</p>
<p>在Python中的私有属性和方法是伪私有，就是有它们只换了一个名，在外部也可以进行访问，只要在私有属性前面加上单引号类名<code>_类名__属性名</code>即可（例如：<code>对象名._类名__属性名</code>，由于是访问，所以加对象名）</p>
<p><strong>Python有三种封装的写法</strong></p>
<blockquote>
<p>（1）直接私有化属性，提供getter和setter<br>（2）直接私有化属性，提供getter和setter，引入了property的全局函数<br>（3）使用property装饰器完成封装</p>
</blockquote>
<h3 id="a-直接私有化属性，提供getter和setter"><a href="#a-直接私有化属性，提供getter和setter" class="headerlink" title="a.直接私有化属性，提供getter和setter"></a>a.直接私有化属性，提供getter和setter</h3><p>这种方法就是提供<code>getter</code>和<code>setter</code>两种方法，比较常用的方法了。</p>
<p><strong>格式</strong></p>
<blockquote>
<p>def 获取属性方法名(self):<br>…return self.__属性名<br>def 设置属性方法名(self, 用户输入的值):<br>self.__属性名 &#x3D; 用户输入的值</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">class Str:
    __name = &quot;cc&quot;
    _age = 18
    def __init__(self, Name):
        self.__name = Name
    #提供name_getter方法来返回name值
    def name_getter(self):
        return self.__name
    #提供name_setter方法来设置name值
    def name_setter(self, Name):
        self.__name = Name
    def S_print(self):
        print(&quot;Name is &#123;&#125;, Age is &#123;&#125;&quot;.format(self.__name, self._age))
s = Str(&quot;qq&quot;)
print(s.name_getter())
s.name_setter(&quot;xx&quot;)
print(s.name_getter())
print(s._age)
print(s.__name)
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/2020030221453052.png" alt="在这里插入图片描述"></p>
<p><strong>由结果可以看出我们在<code>__init__</code>（构造方法）前面定义属性是没必要的，一般情况下，会在构造方法里面定义属性，并赋初值。</strong></p>
<p><strong>有两个下划线的属性是不可以访问的，有单下划线的属性可以访问。</strong></p>
<h3 id="b-直接私有化属性，提供getter和setter，引入了property的全局函数"><a href="#b-直接私有化属性，提供getter和setter，引入了property的全局函数" class="headerlink" title="b.直接私有化属性，提供getter和setter，引入了property的全局函数"></a>b.直接私有化属性，提供getter和setter，引入了property的全局函数</h3><p>这种方法是在上面的方法基础上引入<code>property</code>全局函数，使得在访问属性时更加方便。</p>
<p><strong>函数格式</strong></p>
<blockquote>
<p>class property([fget[, fset[, fdel[, doc]]]])</p>
</blockquote>
<p><strong>参数</strong></p>
<p>fget – 获取属性值的函数<br>fset – 设置属性值的函数<br>fdel – 删除属性值函数<br>doc – 属性描述信息</p>
<p><strong>方法格式</strong></p>
<blockquote>
<p>def 获取属性方法名(self):<br>…return self.__属性名<br>def 设置属性方法名(self, 用户输入的值):<br>self.__属性名 &#x3D; 用户输入的值<br>变量名(推荐属性名，就相当于设置了一个属性)&#x3D;property(设置属性方法名, 获取属性方法名)</p>
</blockquote>
<p><strong>注意：设置属性方法名在前面，获取方法名在后面</strong></p>
<p><strong>代码</strong></p>
<pre><code class="python">class Str:
    def __init__(self, Name):
        self.__name = Name
    #提供name_getter方法来返回name值
    def name_getter(self):
        return self.__name
    #提供name_setter方法来设置name值
    def name_setter(self, Name):
        self.__name = Name

    name = property(name_getter, name_setter)    
    def S_print(self):
        print(&quot;Name is &#123;&#125;, Age is &#123;&#125;&quot;.format(self.__name, self._age))
s = Str(&quot;qq&quot;)
print(s.name)
s.name = &quot;xx&quot;
print(s.name)
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/20200302220943394.png" alt="在这里插入图片描述"></p>
<h3 id="c-使用property装饰器完成封装"><a href="#c-使用property装饰器完成封装" class="headerlink" title="c.使用property装饰器完成封装"></a>c.使用property装饰器完成封装</h3><p>上面的调用方法又略显复杂，这对于追求完美的Python程序员来说，是不太满意的！所以就出现了第三种方法。这种方法是通过<code>@property</code>装饰器负责把一个方法变成只读属性调用。</p>
<p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作。</p>
<p>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<p><strong>格式</strong></p>
<blockquote>
<p>@property<br>def 属性方法名(self):<br>return self.__属性名<br>@属性方法名.setter<br>def 属性方法名(self, 用户输入的值):<br>self.__属性名 &#x3D; 用户输入的值</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">class Str:
    def __init__(self, Name):
        self.__name = Name
        
    @property
    def S_name(self):
        return self.__name

    @S_name.setter
    def S_name(self, Name):
        self.__name = Name

   
    def S_print(self):
        print(&quot;Name is &#123;&#125;, Age is &#123;&#125;&quot;.format(self.__name, self._age))
s = Str(&quot;qq&quot;)
s.name = &quot;xx&quot;
print(s.name)
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/2020030222353735.png" alt="在这里插入图片描述"><br><strong>注意：在使用第三种封装方法时@方法名.setter中必须是setter，而且由于是配对的，所以只有先设置才可以调用。</strong></p>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><p>继承嘛！就是继承父辈的遗产或者知识类似，模拟人类的继承这种方式，子代继承父代的财富或知识。由于面向对象是模拟人类的实现，所以需要有继承关系，即类与类之间的继承关系。其实在Python3.x版本中所有的自定义类都继承<code>object</code>类，但是Python2.x中却不是，Python和C++一样还支持多继承。</p>
<p>当一个类继承其他类（也就是父类，也可以叫超类），那么它就拥有了继承父类的一些方法和属性。如果我们继承了父类的方法和属性，如果这些方法和属性满足我们使用，直接调用就行了。但是如果某个方法或者属性不满足我们的需求可以通过重写（覆盖）代码。</p>
<p><strong>注意：父类的公开方法和属性可以继承，私有方法和属性是不能被继承，但是嘛！上面说了Python是伪私有，所以还是可以通过非正常手段继承父类私有方法的。</strong></p>
<p>super继承两种方法，父类有属性加变量名</p>
<h3 id="a-正常继承"><a href="#a-正常继承" class="headerlink" title="a.正常继承"></a>a.正常继承</h3><p><strong>格式</strong></p>
<blockquote>
<p>class 子类(父类):<br> …类的属性 &#x3D; 属性值<br> …类的方法(self, [参数]):<br> … …方法体<br>#上面那块代码块和之前定义类的形式一样了，就是看你继不继承父类属性和方法了</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">#父类
class People:
    def __init__(self):
        print(&quot;我是父类&quot;)
#子类1
class Employee(People):
    pass
#子类2
class Teacher(People):
    def __init__(self):
        print(&quot;我是子类2&quot;)

P =  People()
E =  Employee()
T = Teacher()
</code></pre>
<p><strong>显示结果</strong><br><img src="https://img-blog.csdnimg.cn/20200302230936514.png" alt="在这里插入图片描述"><br><strong>由结果可以看出一个父类可以有多个子类，就像一个父亲可以有多个孩子一样！</strong></p>
<h3 id="b-非法继承"><a href="#b-非法继承" class="headerlink" title="b.非法继承"></a>b.非法继承</h3><p>一种方法是通过父类名.方法名(self)，这种方法是非绑定，另一种是调用super函数。这种方法是绑定。<br><strong>格式</strong></p>
<blockquote>
<p>父类名.方法名(self)<br>super().<strong>init</strong>()</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">#父类
class People:
    def __init__(self):
        self.__name = &quot;xx&quot;
        print(&quot;我是父类&quot;)
    def P_print(self):
        print(&quot;我是&#123;&#125;&quot;.format(self.__name))
#子类1
class Employee(People):
    def __init__(self):
        People.__init__(self)
        print(&quot;我是子类1\n&quot;)

#子类2
class Teacher(People):
    def __init__(self):
        super().__init__()
        print(&quot;我是子类2\n&quot;)

P =  People()
E =  Employee()
T = Teacher()
P.P_print()
E.P_print()
T.P_print()
</code></pre>
<p><strong>显示结果</strong><br><img src="https://img-blog.csdnimg.cn/20200302233103255.png" alt="在这里插入图片描述"></p>
<h3 id="c-多继承"><a href="#c-多继承" class="headerlink" title="c.多继承"></a>c.多继承</h3><p>多继承的意思就是一个徒弟有多个师傅传授武功。Python中也一样一个子类可以有多个父类，但是不推荐，这种方法很容易使得代码显得复杂，而且容易抛出异常。</p>
<p><strong>格式</strong></p>
<blockquote>
<p>class 子类名(父类1, 父类2,…):</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">#父类1
class People:
    def P_print(self):
        print(&quot;我是父类1&quot;)
#父类2
class Employee:
    def E_print(self):
        print(&quot;我是父类2&quot;)

#子类
class Teacher(People, Employee):
    pass
P =  People()
E =  Employee()
T = Teacher()
P.P_print()
E.E_print()
T.P_print()
T.E_print()
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/20200303001353309.png" alt="在这里插入图片描述"></p>
<h3 id="d-Python没有函数的重载，但是有重写（或者叫覆盖）"><a href="#d-Python没有函数的重载，但是有重写（或者叫覆盖）" class="headerlink" title="d.Python没有函数的重载，但是有重写（或者叫覆盖）"></a>d.Python没有函数的重载，但是有重写（或者叫覆盖）</h3><p>重载就是函数名称相同，函数参数个数、参数类型和返回值可以不同的两个或者两个以上的函数，当我们调用的时候，会自动的执行对应的函数。</p>
<p>而重写就是函数名称，函数参数个数、参数类型和返回值都相同的两个函数或者以上的函数。</p>
<p>由于Python语言本身没有数据类型这一说，加上是脚本语言，变量会随着赋值的改变而改变，所以Python是没有函数重载的，但是Python是支持重写的。</p>
<p><strong>重写格式</strong></p>
<blockquote>
<p>def 父类的方法([参数]):<br>…方法体<br>def 与父类相同名字的子类方法([相同参数]):<br>…不同方法体</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="python">#父类1
class People:
    def P_print(self):
        print(&quot;我是父类&quot;)

#子类
class Teacher(People):
    def P_print(self):
        print(&quot;我是子类&quot;)

P =  People()
T = Teacher()
P.P_print()
T.P_print()
</code></pre>
<p><strong>结果显示</strong><br><img src="https://img-blog.csdnimg.cn/20200303000243321.png" alt="在这里插入图片描述"></p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>多态是在继承的基础上，父类引用指向子类实例（对下个）的现象，就是说父类可以调用子类方法！！！</p>
<p>在Python这些弱类型语音，天生支持多态。</p>
<p>为什么呢？</p>
<p>因为Python是在定义变量、方法名或者类的时候是没有数据类型怎么一说的。首先我们看看C++的多态，假设AList继承List这个父类，那么我们就可以定义：</p>
<pre><code class="python">List a = new AList()
</code></pre>
<p>而在Python中是没有数据类型在变量前面修饰的，就像下面：</p>
<pre><code class="python">a = AList()
</code></pre>
<p>所以在Python这些弱类型语音，天生支持多态。</p>

        </div>
        
        
        <div id="comment">
            <div id="giscus-container" class="giscus"></div>
        </div>
        
    </div>
    
    <div id="article-card">
        <div id="card-style">
    <div id="card-div" class="card-cls">
        <div class="avatar">
            <img src="/images/f6e2b991f74bfd7b88c3ab1a3d513b94.jpg" alt="avatar" />
        </div>
        <div class="name">小C&amp;天天</div>
        <div class="description">
            <p>修学储能 先博后渊</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/A7cc">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.qq.com/">
                    <i class="fa-brands fa-qq fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.weibo.com/">
                    <i class="fa-brands fa-weibo fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://google.com/">
                    <i class="fa-brands fa-google fa-fw"></i>
                </a>
            </span>
            
        </div>
        
        
        <div class="friend-links">
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="http://www.wgs6km.top/">kyrieee</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://tonyd0g.gitee.io/">tonyd0g</a>
            </span>
            
            <span class="friend-link">
                <a target="_blank" rel="noopener" href="https://ruyueattention.github.io/">ruyueattention</a>
            </span>
            
        </div>
        
    </div>
    
    <!-- <br /> -->
    <!-- 目录 -->
    <!-- 
    <div id="card-div">
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81WHY-%E5%AD%A6%E4%B9%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">一、WHY 学习面向对象？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">二、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB"><span class="toc-text">1.类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.类中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">a.内置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-text">b.自定义方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">四、面向对象三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85"><span class="toc-text">1.封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E7%9B%B4%E6%8E%A5%E7%A7%81%E6%9C%89%E5%8C%96%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%8F%90%E4%BE%9Bgetter%E5%92%8Csetter"><span class="toc-text">a.直接私有化属性，提供getter和setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E7%9B%B4%E6%8E%A5%E7%A7%81%E6%9C%89%E5%8C%96%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%8F%90%E4%BE%9Bgetter%E5%92%8Csetter%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86property%E7%9A%84%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-text">b.直接私有化属性，提供getter和setter，引入了property的全局函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%BD%BF%E7%94%A8property%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85"><span class="toc-text">c.使用property装饰器完成封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-text">2.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E6%AD%A3%E5%B8%B8%E7%BB%A7%E6%89%BF"><span class="toc-text">a.正常继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E9%9D%9E%E6%B3%95%E7%BB%A7%E6%89%BF"><span class="toc-text">b.非法继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">c.多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-Python%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E9%87%8D%E5%86%99%EF%BC%88%E6%88%96%E8%80%85%E5%8F%AB%E8%A6%86%E7%9B%96%EF%BC%89"><span class="toc-text">d.Python没有函数的重载，但是有重写（或者叫覆盖）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-text">3.多态</span></a></li></ol></li></ol>
        </div>    
    </div>
     -->
</div>

<div id="card-style-fun">
    
    <!-- 今日诗句 -->
    <br />
    <div id="card-div">
        <div class="good-sentence">
            <div class="toolio">
                <div class="circle"><span class="red"></span></div>
                <div class="circle"><span class="yellow"></span></div>
                <div class="circle"><span class="green"></span></div>
                <div class="circle"><span class="text">今日诗句</span></div>
            </div>
            <div class="sentence">
                <div id="sentenceid" onload="getsentence();"></div>
            </div>
        </div>
    </div>
    <!-- 日期信息 -->
    <br />
    <div id="card-div">
        <img src="//api.vvhan.com/api/ipCard?tip=A7cc" width="300" height="180">
    </div>
    
</div>



    </div>
    
</div>
                <!-- 页脚 -->
                <footer id="footer">
    <div id="footer-wrap">
        <div>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
            <script>
                var now = new Date(); 
                function createtime() { 
                    var grt= new Date("07/10/2022 00:00:00");
                    now.setTime(now.getTime()+250); 
                    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                    document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
                } 
            setInterval("createtime()",250);
            </script>
        </div>
        <div>
            &copy;
            2022 - 2024 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            &commat;小C&amp;天天
        </div>
        <div>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX</a> 
        </div>
        
    </div>
</footer>

            </div>
            <!-- 简单的点击图片放大缩小的预览 -->
            
            <div name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </div>
            
        </div>
        <!-- 看板娘 -->
        
        <div id="L2dCanvas"></div>
        <script src="/js/lib/live2d.min.js"></script>
        <!-- 设置随机模板 -->
        
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "aimierbeierding_2",
                mobile: true,
            });
        </script>
        
        <!-- 诗句 -->
        
        <script>
            // // 每隔10分钟执行一次getsentence这个函数
            window.setInterval(getsentence, 100*60*5);
            function getsentence() {
                // 这里没有考虑IE浏览器，如果需要择if判断加
                var xhr = new XMLHttpRequest();  
                xhr.open('GET', "https://zj.v.api.aa1.cn/api/wenan-shici/?type=json",true);
                xhr.send(JSON.stringify(null));
                xhr.onreadystatechange = function () {
                    if (xhr.status === 200 && xhr.readyState === 4) {
                        //js处理数据
                        // xhr.responseText.match(/content":(".+?")/g)
                        getdata = JSON.parse(xhr.responseText).msg;
                    }else{
                        getdata = "长风破浪会有时，直挂云帆济沧海。——李白《行路难》";
                    }
                    document.getElementById("sentenceid").innerHTML = getdata;
                }
            }
            window.onload = getsentence;
        </script>
        
        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
        <!-- 流星背景特效 -->
        
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/meteorbackground.js"></script>
        
        <script src="/js/main.js"></script>
    </body>
</html>
