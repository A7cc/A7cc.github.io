
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Go基础学习（捌）——假“类” | 小C♥天天</title>
        <meta name="author" content="小C&天天">
        <meta name="description" content="^v^">
        <meta name="keywords" content="">
        <link rel="icon" href="/images/icon.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
        <script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:30vmin;height:30vmin;padding:60px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #dd20dd;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">正在加载</p><div><img alt="loading" src="/images/afde9fa65a5742a90b51d6e1211e841e.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Go基础学习（捌）——假“类” </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/6/18
        </span>
        
        <span class="category">
            <a href="/categories/Go基础教程">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                Go基础教程
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/开发" style="color: #00bcd4">
                    开发
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Go" style="color: #00a596">
                    Go
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h1 id="壹-介绍"><a href="#壹-介绍" class="headerlink" title="壹 介绍"></a>壹 介绍</h1><p>在结构体中我们说过，在Go语言中没有类的概念，也不支持类的继承等面向对象的概念，那为什么这里会又有个类呢？<font color="red">因为在Go语言中，我们可以通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性，所以这里说的类其实是Go语言的结构体的内嵌和接口。</font></p>
<p>注意：Go语言没有类这个概念，只是因为这部分内容有点像其他编程语言的类概念而已。</p>
<span id="more"></span>
<h1 id="贰-构造函数"><a href="#贰-构造函数" class="headerlink" title="贰 构造函数"></a>贰 构造函数</h1><p>那么既然有这个假“类”，那么就要有构造函数，但事实是Go语言是没有面向对象这个概念的，也就没有真正的构造函数，不过这时候我们可以自己实现一个构造函数。</p>
<p>在定义结构体的时候，我们要对结构体进行初始化，如果不初始化的话，那么结构体存储的都是空值，一个方法是直接赋值，另一个方法是使用构造函数，当然这不是让我们决定使用构造函数的原因。<font color="red">使用构造函数的根本原因是因为它可以确保必须执行的任何初始化逻辑均在使用该假”类“之前执行</font>。</p>
<p>那么如何定义一个构造方法？例如，下方有一个<code>student</code>的结构体，然后分别实现一个普通结构体类型的构造函数<code>newStudent1</code>和实现一个结构体指针类型的构造函数<code>newStudent2</code>，其逻辑就是直接返回一个结构体的类型出去。</p>
<pre><code class="go">func 构造函数名(初始化的数据 初始化数据的类型)返回值类型&#123;
    return 结构体类型&#123;
        结构体属性1: 初始化数据1,
        结构体属性2: 初始化数据2,
        ...
    &#125;
&#125;
// 这里需要说明，返回值类型一定是结构体类型，而且不会定义变量名，否则初始化不了结构体的属性
// 其实就和普通的函数定义一样，不过返回的是结构体类型
</code></pre>
<p>接着我们可看到下面的例子，结构体指针类型构造函数占用的内存比普通结构体类型构造函数占用的内存小，<font color="red">这是因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以在某些情况下建议构造函数返回的是结构体指针类型。</font></p>
<pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)
// 定义一个student结构体
type Student struct &#123;
    name string
    age  int
&#125;
// 定义一个newStudent1的普通结构体类型构造函数
func NewStudent1(name string, age int) Student &#123;
    return Student&#123;
        name: name,
        age:  age,
    &#125;
&#125;
// 定义一个newStudent2的结构体指针类型构造函数
func NewStudent2(name string, age int) *Student &#123;
    return &amp;Student&#123;
        name: name,
        age:  age,
    &#125;
&#125;
func main() &#123;
    // 实例化newStudent1
    stu1 := NewStudent1(&quot;A7&quot;, 10)
    fmt.Printf(&quot;stu1数据：%#v\tstu1占的内存大小:%v\n&quot;, stu1, unsafe.Sizeof(stu1)) //stu1数据：main.Student&#123;name:&quot;A7&quot;, age:10&#125;       stu1占的内存大小:24
    // 实例化NewStudent2
    stu2 := NewStudent2(&quot;A7cc&quot;, 20)
    fmt.Printf(&quot;stu2数据：%#v\tstu2占的内存大小:%v\n&quot;, stu2, unsafe.Sizeof(stu2)) //stu2数据：&amp;main.Student&#123;name:&quot;A7cc&quot;, age:20&#125;    stu2占的内存大小:8
&#125;
</code></pre>
<p><font color="red">在定义结构体类型时，尽量第一个字母大写，而构造函数的话，尽量以<code>New+结构体名</code>进行命名，如：<code>NewText</code>。</font></p>
<h1 id="叁-方法和接收者"><a href="#叁-方法和接收者" class="headerlink" title="叁 方法和接收者"></a>叁 方法和接收者</h1><h2 id="3-1-初识方法和接收者"><a href="#3-1-初识方法和接收者" class="headerlink" title="3.1 初识方法和接收者"></a>3.1 初识方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<pre><code class="go">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;
    函数体
&#125;
// 接收者变量：接收者中的参数变量名在命名时
// 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。
// 方法名、参数列表、返回参数：具体格式与函数定义相同。
</code></pre>
<p><font color="red">个人感觉普通函数前面可能是默认前面有接收者变量，方法就是特殊的函数！！！（这是个人见解，这样好理解，但不代表官方）</font></p>
<p>下面是官方的：官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>student</code>类型的接收者变量应该命名为 <code>s</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。<font color="red">方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</font></p>
<p>举个例子：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

// Student 结构体
type Student struct &#123;
    name string
    age  int
&#125;
//NewStudent 构造函数
func NewStudent(name string, age int) *Student &#123;
    return &amp;Student&#123;
        name: name,
        age:  age,
    &#125;
&#125;
// Student的Dream方法
func (s Student) Dream() &#123;
    fmt.Printf(&quot;s的地址是：%p\n&quot;, &amp;s)           // s的地址是：0xc000098078
    fmt.Printf(&quot;s.name的地址是：%p\n&quot;, &amp;s.name) // s.name的地址是：0xc000098078
    fmt.Printf(&quot;s.age的地址是：%p\n&quot;, &amp;s.age)   // s.age的地址是：0xc000098088
    fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, s.name)  // A7cc的梦想是学好Go语言！
    s.age = 19
&#125;
func main() &#123;
    stu1 := NewStudent(&quot;A7cc&quot;, 18)
    stu1.Dream()
    fmt.Printf(&quot;stu1的地址是：%p\n&quot;, &amp;stu1)           // stu1的地址是：0xc0000d8018
    fmt.Printf(&quot;stu1.name的地址是：%p\n&quot;, &amp;stu1.name) // stu1.name的地址是：0xc000098060
    fmt.Printf(&quot;stu1.age的地址是：%p\n&quot;, &amp;stu1.age)   // stu1.age的地址是：0xc000098070
    fmt.Printf(&quot;stu1.age=%v&quot;, stu1.age)          // stu1.age=18
&#125;
</code></pre>
<p><font color="red">根据上面的结果可以看到，传递的接收者变量地址与传入的值的地址不一样。这是因为，传递的接收者变量的类型不是一个指针类型，而是非指针类型或者说是值类型，我们都知道值类型是直接复制一份一模一样的值到另一个内存中，所以此时地址也就不一样了，具体指针类型接收者与值类型接收者介绍在下面小节。</font></p>
<h2 id="3-2-指针类型的接收者"><a href="#3-2-指针类型的接收者" class="headerlink" title="3.2 指针类型的接收者"></a>3.2 指针类型的接收者</h2><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Student</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>
<pre><code class="go">// SetAge1 设置s的年龄
// 使用指针接收者
//Dream Student做梦的方法
func (s *Student) SetAge1(newAge int) &#123;
    fmt.Printf(&quot;s的地址是：%p\n&quot;, &amp;s)           // s的地址是：0xc000006038
    fmt.Printf(&quot;s.name的地址是：%p\n&quot;, &amp;s.name) // s.name的地址是：0xc000004078
    fmt.Printf(&quot;s.age的地址是：%p\n&quot;, &amp;s.age)   // s.age的地址是：0xc000004088
    s.age = newAge
&#125;

func main() &#123;
    stu1 := NewStudent(&quot;A7cc&quot;, 18)
    fmt.Println(stu1.age)
    stu1.SetAge1(26)
    fmt.Printf(&quot;stu1的地址是：%p\n&quot;, &amp;stu1)           // stu1的地址是：0xc000006028
    fmt.Printf(&quot;stu1.name的地址是：%p\n&quot;, &amp;stu1.name) // stu1.name的地址是：0xc000004078
    fmt.Printf(&quot;stu1.age的地址是：%p\n&quot;, &amp;stu1.age)   // stu1.age的地址是：0xc000004088
    fmt.Printf(&quot;stu1.age=%v&quot;, stu1.age)          // stu1.age=26
&#125;
</code></pre>
<p><font color="red">可以看到，其结构体的属性地址在传入方法后是一样的，所以SetAge1方法最后是将<code>age=18</code>改变成了<code>age=26</code>，（以下是个人理解）那么为什么结构体的地址却不一样？因为在方法中并没有进行结构体本身的指针传递，那么就只能将其复制一份属性地址相同但本身地址不同的副本给方法了。</font></p>
<h2 id="3-3-值类型的接收者"><a href="#3-3-值类型的接收者" class="headerlink" title="3.3 值类型的接收者"></a>3.3 值类型的接收者</h2><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<pre><code class="go">// SetAge2 设置p的年龄
// 使用值接收者
//Dream Student做梦的方法
func (s Student) SetAge2(newAge int) &#123;
    fmt.Printf(&quot;s的地址是：%p\n&quot;, &amp;s)           // s的地址是：0xc000098078
    fmt.Printf(&quot;s.name的地址是：%p\n&quot;, &amp;s.name) // s.name的地址是：0xc000098078
    fmt.Printf(&quot;s.age的地址是：%p\n&quot;, &amp;s.age)   // s.age的地址是：0xc000098088
    s.age = newAge
&#125;
func main() &#123;
    stu1 := NewStudent(&quot;A7cc&quot;, 18)
    fmt.Println(stu1.age)
    stu1.SetAge2(26)
    fmt.Printf(&quot;stu1的地址是：%p\n&quot;, &amp;stu1)           // stu1的地址是：0xc0000d8018
    fmt.Printf(&quot;stu1.name的地址是：%p\n&quot;, &amp;stu1.name) // stu1.name的地址是：0xc000098060
    fmt.Printf(&quot;stu1.age的地址是：%p\n&quot;, &amp;stu1.age)   // stu1.age的地址是：0xc000098070
    fmt.Printf(&quot;stu1.age=%v&quot;, stu1.age)          // stu1.age=18
&#125;
</code></pre>
<p>由于是值传递，是复制一份副本，所以使用<code>SetAge2</code>方法不能改变<code>age</code>的值。</p>
<h2 id="3-4-什么时候应该使用指针类型接收者"><a href="#3-4-什么时候应该使用指针类型接收者" class="headerlink" title="3.4 什么时候应该使用指针类型接收者"></a>3.4 什么时候应该使用指针类型接收者</h2><ul>
<li>a.需要修改接收者中的值</li>
<li>b.接收者是拷贝代价比较大的大对象</li>
<li>c.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ul>
<h1 id="肆-任意类型添加方法"><a href="#肆-任意类型添加方法" class="headerlink" title="肆 任意类型添加方法"></a>肆 任意类型添加方法</h1><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<p><font color="red"><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。就是说像<code>int</code>、<code>float32</code>、<code>bool</code>、<code>string</code>这些在别的包已经定义的类型不可以定义方法，但是我们可以使用<code>type</code>对其进行创建一个新的类型，再添加方法。</font></p>
<pre><code class="go">//MyInt 将int定义为自定义MyInt类型
type MyInt int

// 我们可以看到通过type可以自定义一个类型
func (a MyInt) text1(top1 int) &#123;
    fmt.Printf(&quot;MyInt本质是一个int类型，我们传递了参数：%v&quot;, top1)
&#125;
// 如果将下面注释的方法定义使用，会报错，原因就是因为非本地类型不能定义方法
// func (b int) text2(top2 int) &#123;
// 	fmt.Printf(&quot;int类型不能添加方法，我们传递了参数：%v&quot;, top2)
// &#125;

func main() &#123;
    var val1 MyInt
    // 注意需要定义一个MyInt型变量才能调用该类型变量的方法
    val1.text1(1)
    // var val2 int
    // val2.text2(2)
&#125;
</code></pre>
<p><font color="red">注意：需要定义一个MyInt型变量才能调用该类型变量的方法。</font></p>
<h1 id="伍-结构体的匿名字段"><a href="#伍-结构体的匿名字段" class="headerlink" title="伍 结构体的匿名字段"></a>伍 结构体的匿名字段</h1><p>结构体<strong>允许</strong>其成员字段在声明时没有字段名（属性名）而只有类型，这种没有名字的字段就称为<strong>匿名字段</strong>。个人不建议使用，增加了代码阅读量，也容易导致代码重复。</p>
<p><font color="red">注意：这里匿名字段的说法并不代表没有字段名（属性名），而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个，而其他同类型必须要有字段名（属性名）进行区分。</font></p>
<pre><code class="go">// Student 结构体
type Student struct &#123;
    string
    class  string
    number int
    int
&#125;
func main() &#123;
    stu1 := Student&#123;
        &quot;A7cc&quot;,
        &quot;六年三班&quot;,
        12,
        18,
    &#125;
    fmt.Printf(&quot;%#v\n&quot;, stu1) // main.Student&#123;string:&quot;A7cc&quot;, class:&quot;六年三班&quot;, number:12, int:18&#125;
    fmt.Printf(&quot;名字是：%v，学号是%v，班级是：%v，年龄是%v&quot;, stu1.string, stu1.number, stu1.class, stu1.int) // 名字是：A7cc，学号是12，班级是：六年三班，年龄是18
&#125;
</code></pre>
<h1 id="陆-嵌套结构体"><a href="#陆-嵌套结构体" class="headerlink" title="陆 嵌套结构体"></a>陆 嵌套结构体</h1><h2 id="6-1-基础的嵌套结构体"><a href="#6-1-基础的嵌套结构体" class="headerlink" title="6.1 基础的嵌套结构体"></a>6.1 基础的嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

//Address 地址结构体
type Address struct &#123;
    Province string // 省份
    City     string // 城市
&#125;

//User 用户结构体
type User struct &#123;
    Name   string  // 名字
    Gender string  // 性别
    Addres Address // 地址，引用了Address结构体，也可以引用结构体指针
&#125;

func main() &#123;
    user1 := User&#123;
        Name:   &quot;A7cc&quot;,
        Gender: &quot;男&quot;,
        Addres: Address&#123;
            Province: &quot;陕西&quot;,
            City:     &quot;西安&quot;,
        &#125;,
    &#125;
    fmt.Printf(&quot;user1=%#v\n&quot;, user1) //user1=main.User&#123;Name:&quot;A7cc&quot;, Gender:&quot;男&quot;, Address:main.Addres&#123;Province:&quot;陕西&quot;, City:&quot;西安&quot;&#125;&#125;
    user1.Addres.Province = &quot;四川&quot;     // 访问Addres的字段时需要加上Addres
    user1.Addres.City = &quot;成都&quot;
    fmt.Printf(&quot;user1=%#v\n&quot;, user1) // user1=main.User&#123;Name:&quot;A7cc&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;四川&quot;, City:&quot;成都&quot;&#125;&#125;
&#125;
</code></pre>
<h2 id="6-2-嵌套匿名字段"><a href="#6-2-嵌套匿名字段" class="headerlink" title="6.2 嵌套匿名字段"></a>6.2 嵌套匿名字段</h2><p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p>
<pre><code class="go">//Address 地址结构体
type Address struct &#123;
    Province string // 省份
    City     string // 城市
&#125;

//User 用户结构体
type User struct &#123;
    Name    string // 名字
    Gender  string // 性别
    Address        // 地址，引用了Address结构体，这里也可以是结构体指针，范围的话，直接用.即可，但是匿名只能是一个结构体或者是结构体指针，因为类型名只能给其中一个
&#125;

func main() &#123;
    user1 := User&#123;
        Name:   &quot;A7cc&quot;,
        Gender: &quot;男&quot;,
        Address: Address&#123; // 由于省略了类型，使用字段名就是类型名
            Province: &quot;陕西&quot;,
            City:     &quot;西安&quot;,
        &#125;,
    &#125;
    fmt.Printf(&quot;user1=%#v\n&quot;, user1) //user1=main.User&#123;Name:&quot;A7cc&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;陕西&quot;, City:&quot;西安&quot;&#125;&#125;
    user1.Address.Province = &quot;四川&quot;    // 匿名字段默认使用类型名作为字段名
    user1.City = &quot;成都&quot;                // 可以看到再访问匿名字段时可以省略结构体类型，但是字段名有名字时不可以省略，如上面那个例子，这是因为当访问结构体成员时会先在结构体中查找该字段名，如果找不到就会去嵌套的匿名字段中查找
    fmt.Printf(&quot;user1=%#v\n&quot;, user1) // user1=main.User&#123;Name:&quot;A7cc&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;四川&quot;, City:&quot;成都&quot;&#125;&#125;
</code></pre>
<p><font color="red">当访问结构体成员时会先在结构体中查找该字段名，如果找不到就会去嵌套的匿名字段中查找，所以建议使用具体的内嵌结构体字段名。</font></p>
<h2 id="6-3-嵌套结构体的字段名冲突"><a href="#6-3-嵌套结构体的字段名冲突" class="headerlink" title="6.3 嵌套结构体的字段名冲突"></a>6.3 嵌套结构体的字段名冲突</h2><p>那么现在有个问题如果一个结构体嵌套了两个结构体，并且这两个结构体的字段名存在相同的名字，即嵌套结构体内部存在相同的字段名。所以在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>
<pre><code class="go">//Address 地址结构体
type Address struct &#123;
    Province   string
    City       string
    CreateTime string
&#125;

//Email 邮箱结构体
type Email struct &#123;
    Account    string
    CreateTime string
&#125;

//User 用户结构体
type User struct &#123;
    Name   string
    Gender string
    Address
    Email
&#125;

func main() &#123;
    var user1 User
    user1.Name = &quot;A7cc&quot;
    user1.Gender = &quot;男&quot;
    // user1.CreateTime = &quot;2019&quot;
    user1.Address.CreateTime = &quot;2000&quot; //指定Address结构体中的CreateTime
    user1.Email.CreateTime = &quot;2000&quot;   //指定Email结构体中的CreateTime
&#125;
</code></pre>
<h1 id="柒-结构体的“继承”"><a href="#柒-结构体的“继承”" class="headerlink" title="柒 结构体的“继承”"></a>柒 结构体的“继承”</h1><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<pre><code class="go">//Animal 动物
type Animal struct &#123;
    name string
&#125;

// 定义一个Animal的独有的方法move
func (a *Animal) move() &#123;
    fmt.Printf(&quot;%s是动物，会动！\n&quot;, a.name)
&#125;

// 定义一个Animal的方法dream
func (a *Animal) dream() &#123;
    fmt.Printf(&quot;%s是动物，梦想是成为百兽之王！\n&quot;, a.name)
&#125;

//Dog 狗
type Dog struct &#123;
    Feet    int8
    *Animal //通过嵌套匿名结构体实现继承
&#125;

// 定义一个Dog的独有的方法wang
func (d *Dog) wang() &#123;
    fmt.Printf(&quot;%s是狗，会汪汪汪~\n&quot;, d.name)
&#125;

// 定义一个Dog的方法dream，方法名与前面的Animal的dream重名
func (d *Dog) dream() &#123;
    fmt.Printf(&quot;%s是狗，梦想是成为人类忠诚的朋友！\n&quot;, d.name)
&#125;
func main() &#123;
    d1 := &amp;Dog&#123;
        Feet: 4,
        Animal: &amp;Animal&#123; //注意嵌套的是结构体指针
            name: &quot;狗狗&quot;,
        &#125;,
    &#125;
    d1.wang() // 狗狗是狗，会汪汪汪~
    d1.move() // 狗狗是动物，会动！
    d1.dream() // 狗狗是狗，梦想是成为人类忠诚的朋友！
    d1.Animal.dream() // 狗狗是动物，梦想是成为百兽之王！
&#125;
</code></pre>
<p><font color="red">可以看到结构体通过嵌套匿名结构体的方法实现继承，然后可以直接调用继承的结构体的方法，但是，当结构体A本身与结构体A继承的结构体B存在相同方法名时，会先调用A本身的方法，而不是B的方法。</font>由此更验证了，当访问结构体成员或者方法时会先在结构体中查找该字段或者该方法，找不到再去嵌套的匿名字段中查找。</p>
<h1 id="捌-结构体字段的可见性（需要注意）"><a href="#捌-结构体字段的可见性（需要注意）" class="headerlink" title="捌 结构体字段的可见性（需要注意）"></a>捌 结构体字段的可见性（需要注意）</h1><p><font color="red">结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问，其他的包不可以访问）。</font>可以看出，结构体真的很像类。</p>
<pre><code class="go">package main

import (
    // 这个是Go语言的序列化库
    &quot;encoding/json&quot;
    &quot;fmt&quot;
)

//Student 学生
type Student struct &#123;
    ID     int
    Gender string
    name   string	// 私有不能被json包访问
&#125;

func main() &#123;
    stu1 := Student&#123;
        ID:     1,
        Gender: &quot;六年级三班&quot;,
        name:   &quot;A7cc&quot;,
    &#125;
    // 将stu1进行序列化
    date, _ := json.Marshal(stu1)
    fmt.Printf(&quot;%s&quot;, date)	// &#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;六年级三班&quot;&#125;
&#125;
</code></pre>
<p>可以看到，name字段没有被json包访问成功。</p>
<h1 id="玖-结构体和方法补充知识点（注意）"><a href="#玖-结构体和方法补充知识点（注意）" class="headerlink" title="玖 结构体和方法补充知识点（注意）"></a>玖 结构体和方法补充知识点（注意）</h1><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意，使用<code>=</code>复制的时候就是指针的传递。我们来看下面的例子：</p>
<pre><code class="go">type Person struct &#123;
    name   string
    age    int8
    dreams []string
&#125;

func (p *Person) SetDreams(dreams []string) &#123;
    // 这里就是将dreams的切片地址赋值给p.dreams
    p.dreams = dreams
    // 真正的做法应该是像切片操作一样使用copy函数，即下面操作
    // 	p.dreams = make([]string, len(dreams))
    // 	copy(p.dreams, dreams)
&#125;

func main() &#123;
    p1 := Person&#123;name: &quot;小王子&quot;, age: 18&#125;
    data := []string&#123;&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;&#125;
    p1.SetDreams(data)

    // 你真的想要修改 p1.dreams 吗？
    data[1] = &quot;不睡觉&quot;
    fmt.Println(p1.dreams)  // 会发现不但修改了data的值而且还修改了p1.dreams的值
&#125;
</code></pre>
<p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            @小C&天天
        </div>
        <div>
            备案号：小C&天天の窝
        </div>
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

        <!-- 3D模型 -->
        <div id="L2dCanvas" style="position: relative;"></div>
        <script src="/js/live2d.min.js"></script>
        <script src="/css/live2d.css"></script>
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "zhala_2",
                mobile: true,
            });
        </script>
        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
        <!-- 流星背景特效 -->
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/background.js"></script>
    </body>
</html>