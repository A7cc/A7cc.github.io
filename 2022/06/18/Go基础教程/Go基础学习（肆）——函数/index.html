
<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Go基础学习（肆）——函数 | 小C♥天天</title>
        <meta name="author" content="小C&天天">
        <meta name="description" content="^v^">
        <meta name="keywords" content="">
        <link rel="icon" href="/images/icon.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
        <script src="https://cdn.staticfile.org/pixi.js/4.6.1/pixi.min.js"></script>

    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:30vmin;height:30vmin;padding:60px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #dd20dd;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">正在加载</p><div><img alt="loading" src="/images/afde9fa65a5742a90b51d6e1211e841e.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">小C♥天天</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;档案</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
        <a href="/tools">
            <i class="fa-solid fa-tools fa-fw"></i>
            <span>&ensp;工具</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小C♥天天</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">档案</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                </div>
            </a>
            
            <a href="/tools">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tools fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">工具</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Go基础学习（肆）——函数 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/6/18
        </span>
        
        <span class="category">
            <a href="/categories/Go基础教程">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                Go基础教程
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Go" style="color: #03a9f4">
                    Go
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/开发" style="color: #ffa2c4">
                    开发
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h1 id="壹-前言"><a href="#壹-前言" class="headerlink" title="壹 前言"></a>壹 前言</h1><p>在学习函数之前，需要明白为什么要学习函数？</p>
<span id="more"></span>
<p>首先有这么一段代码：</p>
<p><strong>代码1：</strong></p>
<pre><code class="go">fmt.Println(&quot;Hello!World!&quot;)
fmt.Println(&quot;Hello!World!&quot;)
fmt.Println(&quot;Hello!World!&quot;)
fmt.Println(&quot;Hello!World!&quot;)
fmt.Println(&quot;Hello!World!&quot;)
fmt.Println(&quot;Hello!World!&quot;)
</code></pre>
<p><strong>代码2：</strong></p>
<pre><code class="go">#这段代码的意思是将6句Hello!World!放进fun()自定义函数中，并调用fun()函数
func fun()&#123;
    fmt.Println(&quot;Hello!World!&quot;)
    fmt.Println(&quot;Hello!World!&quot;)
    fmt.Println(&quot;Hello!World!&quot;)
    fmt.Println(&quot;Hello!World!&quot;)
    fmt.Println(&quot;Hello!World!&quot;)
    fmt.Println(&quot;Hello!World!&quot;)
fun()
</code></pre>
<p><strong>也许现在会很疑惑，这不就是简单的fmt.Println函数打印6遍而已吗？</strong><br>是的，他们看上去差不多，甚至有人会觉得代码2比代码1复杂许多，但是你想想如果这6句Hello!World!不是单单在一处地方打印时，而是上百处上千处时，那要把代码1打印多久？而代码2只要把定义写完，想在那打印就调用一下即可。函数在刚学习的时候不容易发现他的长处，甚至觉得比较麻烦，但是到了以后做大项目的时候，会发现编程因为有了函数而变得有趣和简洁。</p>
<h1 id="贰-什么是函数"><a href="#贰-什么是函数" class="headerlink" title="贰 什么是函数"></a>贰 什么是函数</h1><p>函数是基本的代码块，用于执行一个任务，Go 语言最少有个 <code>main()</code> 函数，你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务，函数声明告诉了编译器函数的名称，返回类型，和参数。</p>
<p>Go 语言标准库提供了多种可动用的内置的函数。例如，<code>len()</code> 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p>
<h1 id="叁-创建函数"><a href="#叁-创建函数" class="headerlink" title="叁 创建函数"></a>叁 创建函数</h1><p><strong>格式</strong></p>
<pre><code class="go">func 函数名( [参数] ) [返回值] &#123;
   函数体
    [return]
&#125;
</code></pre>
<ul>
<li>func：函数由 <code>func</code> 开始声明</li>
<li>函数名：函数名称，参数列表和返回值类型构成了函数签名。</li>
<li>参数：参数列表，参数由参数变量和参数变量的类型组成，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数是可选的，也就是说函数也可以不包含参数。多个参数之间使用<code>,</code>分隔。</li>
<li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。有些功能不需要返回值，这种情况下返回值不是必须的，就不写了。</li>
<li>函数体：实现指定功能的代码块。</li>
<li>return：要返回的值，根据返回值确定需不需要，需要就返回值，不需要就不写。</li>
</ul>
<p><strong>代码</strong></p>
<pre><code class="go">func funtext( x int ) int &#123;
    y := x + 1
    return y
&#125;
</code></pre>
<h1 id="肆-函数的调用以及返回值"><a href="#肆-函数的调用以及返回值" class="headerlink" title="肆 函数的调用以及返回值"></a>肆 函数的调用以及返回值</h1><h2 id="4-1-多返回值"><a href="#4-1-多返回值" class="headerlink" title="4.1 多返回值"></a>4.1 多返回值</h2><p>当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。定义好后的函数，我们直接根据函数加对应参数，即可调用，同时go可以根据函数的<code>[返回值]</code>个数返回对应多个值。<font color="red">如果有返回类型，但是不返回return的话，会报错，所以有几个[返回值]，就要有就几个返回值</font>。<br><strong>格式：</strong></p>
<pre><code class="go">func 函数名( [参数] ) [返回值类型] &#123;
   函数体
    return 返回值1,返回值2,...
&#125;
// 调用通过 函数名([参数])的方式调用函数，这里的参数根据定义函数时有无参数决定的，没有不用写
函数名([参数])
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    sum1, sum2 := 10, 20
    fmt.Println(fun(sum1, sum2))
&#125;
//返回多少个值，[返回值类型]内就需要多少个类型，当然如果没有的话就不用写返回类型和return
func fun(a int, b int) (int, int) &#123;
    //这里如果没有下面这行返回对应数量返回值的话会报错
    return a + b, b
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/2e4e8261f8de7534f0b664abe5ac4abb.png" alt="2e4e8261f8de7534f0b664abe5ac4abb.png"></p>
<h2 id="4-2-返回值命名"><a href="#4-2-返回值命名" class="headerlink" title="4.2 返回值命名"></a>4.2 返回值命名</h2><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。<br><strong>格式：</strong></p>
<pre><code class="go">func 函数名( [参数] ) (返回值1 返回值类型1, 返回值2 返回值类型2,...) &#123;
    函数体
    return
&#125;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    ret1, ret2 := calc(100, 200)
    fmt.Println(ret1, ret2)
&#125;
func calc(x, y int) (sum, sub int) &#123;
    sum = x + y
    sub = x - y
    return
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/6ddf853a7737c981a864f0c3029ea9ef.png" alt="6ddf853a7737c981a864f0c3029ea9ef.png"></p>
<h2 id="4-3-返回值补充"><a href="#4-3-返回值补充" class="headerlink" title="4.3 返回值补充"></a>4.3 返回值补充</h2><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<pre><code class="go">func someFunc(x string) []int &#123;
    if x == &quot;&quot; &#123;
        return nil // 没必要返回[]int&#123;&#125;
    &#125;
    ...
&#125;
</code></pre>
<h1 id="伍-参数传递以及函数参数"><a href="#伍-参数传递以及函数参数" class="headerlink" title="伍 参数传递以及函数参数"></a>伍 参数传递以及函数参数</h1><p>函数如果使用参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。调用函数，可以通过两种方式来传递参数：值传递、引用传递。<br>传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<h2 id="5-1-值传递"><a href="#5-1-值传递" class="headerlink" title="5.1 值传递"></a>5.1 值传递</h2><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br><font color="red">默认情况下，Go 语言调用函数使用的是值传递，即在调用过程中不会影响到实际参数。</font></p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    /* 定义局部变量 */
    a, b := 100, 200
    fmt.Printf(&quot;交换前 a 的值为 : %d\n交换前 b 的值为 : %d\n&quot;, a, b)
    /* 通过调用函数来交换值 */
    swap(a, b)
    fmt.Printf(&quot;交换后 a 的值 : %d\n交换后 b 的值 : %d\n&quot;, a, b)
&#125;
/* 定义相互交换值的函数 */
func swap(x, y int) int &#123;
    var temp int
    temp = x /* 保存 x 的值 */
    x = y    /* 将 y 值赋给 x */
    y = temp /* 将 temp 值赋给 y*/
    return temp
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/05c2df0808beee12690e6b86b2e34731.png" alt="05c2df0808beee12690e6b86b2e34731.png"><br>函数中使用的是值传递，所以两个值并没有实现交互。</p>
<h2 id="5-2-引用传递（需要后面的指针知识）"><a href="#5-2-引用传递（需要后面的指针知识）" class="headerlink" title="5.2 引用传递（需要后面的指针知识）"></a>5.2 引用传递（需要后面的指针知识）</h2><p><font color="green">这个知识我们了解就行，后面学习了指针再回来学习。</font><br>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。<br>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    /* 定义局部变量 */
    a, b := 100, 200
    fmt.Printf(&quot;交换前 a 的值为 : %d\n交换前 b 的值为 : %d\n&quot;, a, b)
    /* 调用 swap() 函数
     * &amp;a 指向 a 指针，a 变量的地址
     * &amp;b 指向 b 指针，b 变量的地址
     */
    swap(&amp;a, &amp;b)
    fmt.Printf(&quot;交换后 a 的值 : %d\n交换后 b 的值 : %d\n&quot;, a, b)
&#125;

func swap(x *int, y *int) &#123;
    var temp int
    temp = *x /* 保存 x 地址上的值 */
    *x = *y   /* 将 y 值赋给 x */
    *y = temp /* 将 temp 值赋给 y */
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/cc23735115080b1cf89e3be46835935d.png" alt="cc23735115080b1cf89e3be46835935d.png"></p>
<h2 id="5-3-普通参数"><a href="#5-3-普通参数" class="headerlink" title="5.3 普通参数"></a>5.3 普通参数</h2><p>普通参数定义，例如：</p>
<pre><code class="go">// 通常情况下每个参数都包含参数名和类型
func intSum1(x int, y int) int &#123;
    return x + y
&#125;
// 而如果相邻变量的类型相同，则可以省略类型
func intSum2(x, y int) int &#123;
    return x + y
&#125;
//intSum2函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型
</code></pre>
<h2 id="5-4-可变参数"><a href="#5-4-可变参数" class="headerlink" title="5.4 可变参数"></a>5.4 可变参数</h2><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。<font color="red">注意：可变参数通常作为函数的最后一个参数。</font></p>
<p>例子：</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    ret5 := intSum2(100)
    ret6 := intSum2(100, 10)
    ret7 := intSum2(100, 10, 20)
    ret8 := intSum2(100, 10, 20, 30)
    fmt.Println(ret5, ret6, ret7, ret8)
&#125;
func intSum2(x int, y ...int) int &#123;
    fmt.Println(x, y)
    sum := x
    for _, v := range y &#123;
        sum = sum + v
    &#125;
    return sum
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/bf4b94d76c67fc7d4de80ac5814c5328.png" alt="bf4b94d76c67fc7d4de80ac5814c5328.png"><br>本质上，函数的可变参数是通过切片来实现的。</p>
<h1 id="陆-函数数组传参"><a href="#陆-函数数组传参" class="headerlink" title="陆 函数数组传参"></a>陆 函数数组传参</h1><p>如果你想向函数传递数组参数，你需要在函数定义时，声明形参为数组，我们可以通过以下方式来声明：</p>
<ul>
<li>形参设定数组大小：<pre><code class="go">void myFunction(param [10]int)&#123;
  ...
&#125;
</code></pre>
例子：<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
 /* 数组长度为 5 */
 var balance = [5]int &#123;1000, 2, 3, 17, 50&#125;
 var avg float32
 /* 数组作为参数传递给函数 */
 avg = getAverage( balance, 5 ) ;
 /* 输出返回的平均值 */
 fmt.Printf( &quot;平均值为: %f &quot;, avg );
&#125;
func getAverage(arr [5]int, size int) float32 &#123;
 var i,sum int
 var avg float32  
 for i = 0; i &lt; size;i++ &#123;
    sum += arr[i]
 &#125;
 avg = float32(sum) / float32(size)
 return avg;
&#125;
</code></pre>
<img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/00ac9becc6cc56f3aafcee032018d7a9.png" alt="00ac9becc6cc56f3aafcee032018d7a9.png"></li>
</ul>
<h1 id="柒-函数类型与变量"><a href="#柒-函数类型与变量" class="headerlink" title="柒 函数类型与变量"></a>柒 函数类型与变量</h1><h2 id="7-1-定义函数类型"><a href="#7-1-定义函数类型" class="headerlink" title="7.1 定义函数类型"></a>7.1 定义函数类型</h2><p>假设我们要将函数定义成一个可以在不同场景下使用，但是功能一样的函数时，我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>
<pre><code class="go">type calculation func(int, int) int
//用于定义函数类型
//calculation为函数类型名字
</code></pre>
<p>上面语句定义了一个叫<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<pre><code class="go">func add(x, y int) int &#123;
    return x + y
&#125;

func sub(x, y int) int &#123;
    return x - y
&#125;
</code></pre>
<p>add和sub都能赋值给calculation类型的变量。</p>
<pre><code class="go">var c calculation
c = add
</code></pre>
<h2 id="7-2-函数类型变量"><a href="#7-2-函数类型变量" class="headerlink" title="7.2 函数类型变量"></a>7.2 函数类型变量</h2><p>我们可以声明函数类型的变量并且为该变量赋值：</p>
<pre><code class="go">func main() &#123;
    var c calculation               // 声明一个calculation类型的变量c
    c = add                         // 把add赋值给c，这里的add函数是上面定义过的，这里只是引用
    fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation
    fmt.Println(c(1, 2))            // 像调用add一样调用c
    f := add                        // 将函数add赋值给变量f1
    fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int
    fmt.Println(f(10, 20))          // 像调用add一样调用f
&#125;
</code></pre>
<p><font color="red">需要明白一点，在函数赋值给其他变量时，如果带括号返回的是retuen的值，不是本身，而如果不带括号，则是函数本身赋值给其他变量。</font></p>
<h1 id="捌-高阶函数"><a href="#捌-高阶函数" class="headerlink" title="捌 高阶函数"></a>捌 高阶函数</h1><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>
<h2 id="8-1-函数作为参数"><a href="#8-1-函数作为参数" class="headerlink" title="8.1 函数作为参数"></a>8.1 函数作为参数</h2><p>函数可以作为参数：</p>
<pre><code class="go">func add(x, y int) int &#123;
    return x + y
&#125;
func calc(x, y int, funtext func(int, int) int) int &#123;
    return funtext(x, y)
&#125;
func main() &#123;
    ret2 := calc(10, 20, add)
    fmt.Println(ret2) //30
&#125;
</code></pre>
<h2 id="8-2-函数作为返回值"><a href="#8-2-函数作为返回值" class="headerlink" title="8.2 函数作为返回值"></a>8.2 函数作为返回值</h2><p>函数也可以作为返回值：</p>
<pre><code class="go">func add(x, y int) int &#123;
    return x + y
&#125;
func sub(x, y int) int &#123;
    return x - y
&#125;
func do(s string) (func(int, int) int, error) &#123;
    switch s &#123;
    case &quot;+&quot;:
        return add, nil
    case &quot;-&quot;:
        return sub, nil
    default:
        err := errors.New(&quot;无法识别的操作符&quot;)
        return nil, err
    &#125;
&#125;
</code></pre>
<h1 id="玖-闭包以及匿名函数"><a href="#玖-闭包以及匿名函数" class="headerlink" title="玖 闭包以及匿名函数"></a>玖 闭包以及匿名函数</h1><h2 id="9-1-匿名函数"><a href="#9-1-匿名函数" class="headerlink" title="9.1 匿名函数"></a>9.1 匿名函数</h2><p><font color="red">在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数</font>，匿名函数就是没有函数名的函数，匿名函数多用于实现回调函数和闭包。</p>
<h3 id="9-1-1-格式"><a href="#9-1-1-格式" class="headerlink" title="9.1.1 格式"></a>9.1.1 格式</h3><p>匿名函数的定义格式如下：</p>
<pre><code class="go">//可以看到没有函数名，而是将其赋值给一个变量，不赋值到变量里，该匿名函数就没有意义，或者直接在后面加参数执行，具体实现下面会讲
valfun := func(参数)(返回值)&#123;
    函数体
&#125;
</code></pre>
<h3 id="9-1-2-例子"><a href="#9-1-2-例子" class="headerlink" title="9.1.2 例子"></a>9.1.2 例子</h3><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数：</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func main() &#123;
    // 将匿名函数保存到变量
    add := func(x, y int) &#123;
        fmt.Println(x + y)
    &#125;
    add(10, 20) // 通过变量调用匿名函数
    //自执行函数：匿名函数定义完加()直接执行
    func(x, y int) &#123;
        fmt.Println(x + y)
    &#125;(10, 20)
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/d7342241e34645c6619cf2825ce48c66.png" alt="d7342241e34645c6619cf2825ce48c66.png"></p>
<h2 id="9-2-闭包"><a href="#9-2-闭包" class="headerlink" title="9.2 闭包"></a>9.2 闭包</h2><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：</p>
<pre><code class="go">func adder() func(int) int &#123;
    var x int
    return func(y int) int &#123;
        x += y
        return x
    &#125;
&#125;
func main() &#123;
    var f = adder()
    fmt.Println(f(10)) //10
    fmt.Println(f(20)) //30
    fmt.Println(f(30)) //60

    f1 := adder()
    fmt.Println(f1(40)) //40
    fmt.Println(f1(50)) //90
&#125;
</code></pre>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。<font color="red">可以看到闭包就是将adder这个函数的返回值（一个匿名函数）和adder函数内的作用域环境给<code>f</code>。</font></p>
<p>闭包进阶示例1：</p>
<pre><code class="go">func adder2(x int) func(int) int &#123;
    return func(y int) int &#123;
        x += y
        return x
    &#125;
&#125;
func main() &#123;
    var f = adder2(10)
    fmt.Println(f(10)) //20
    fmt.Println(f(20)) //40
    fmt.Println(f(30)) //70

    f1 := adder2(20)
    fmt.Println(f1(40)) //60
    fmt.Println(f1(50)) //110
&#125;
</code></pre>
<p>闭包进阶示例2：</p>
<pre><code class="go">func makeSuffixFunc(suffix string) func(string) string &#123;
    return func(name string) string &#123;
        if !strings.HasSuffix(name, suffix) &#123;
            return name + suffix
        &#125;
        return &quot;1&quot;
    &#125;
&#125;
func main() &#123;
    jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)
    txtFunc := makeSuffixFunc(&quot;.txt&quot;)
    fmt.Println(jpgFunc(&quot;.jpg&quot;)) //1
    fmt.Println(txtFunc(&quot;test&quot;)) //test.txt
&#125;
</code></pre>
<p>闭包进阶示例3：</p>
<pre><code class="go">func calc(base int) (func(int) int, func(int) int) &#123;
    add := func(i int) int &#123;
        base += i
        return base
    &#125;

    sub := func(i int) int &#123;
        base -= i
        return base
    &#125;
    return add, sub
&#125;

func main() &#123;
    f1, f2 := calc(10)
    fmt.Println(f1(1), f2(2)) //11 9
    fmt.Println(f1(3), f2(4)) //12 8
    fmt.Println(f1(5), f2(6)) //13 7
&#125;
</code></pre>
<p><font color="red">闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</font></p>
<h1 id="拾-递归函数"><a href="#拾-递归函数" class="headerlink" title="拾 递归函数"></a>拾 递归函数</h1><h2 id="10-1-递归介绍"><a href="#10-1-递归介绍" class="headerlink" title="10.1 递归介绍"></a>10.1 递归介绍</h2><p>递归，就是在运行的过程中调用自己。语法格式如下：</p>
<pre><code class="go">func recursion() &#123;
   recursion() /* 函数调用自身 */
&#125;
func main() &#123;
    recursion()
&#125;
</code></pre>
<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p>
<h2 id="10-2-阶乘"><a href="#10-2-阶乘" class="headerlink" title="10.2 阶乘"></a>10.2 阶乘</h2><p>以下实例通过 Go 语言的递归函数实例阶乘：</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func Factorial(n uint64)(result uint64) &#123;
    if (n &gt; 0) &#123;
        result = n * Factorial(n-1)
        return result
    &#125;
    return 1
&#125;
func main() &#123;  
    var i int = 15
    fmt.Printf(&quot;%d 的阶乘是 %d\n&quot;, i, Factorial(uint64(i)))
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/268db5642aa83cbbf2d1086dae55c6c0.png" alt="268db5642aa83cbbf2d1086dae55c6c0.png"></p>
<h2 id="10-3-斐波那契数列"><a href="#10-3-斐波那契数列" class="headerlink" title="10.3 斐波那契数列"></a>10.3 斐波那契数列</h2><p>以下实例通过 Go 语言的递归函数实现斐波那契数列：</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func fibonacci(n int) int &#123;
  if n &lt; 2 &#123;
   return n
  &#125;
  return fibonacci(n-2) + fibonacci(n-1)
&#125;
func main() &#123;
    var i int
    for i = 0; i &lt; 10; i++ &#123;
       fmt.Printf(&quot;%d\t&quot;, fibonacci(i))
    &#125;
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/520cb49ad09f0e675cf97a5944ab30d2.png" alt="520cb49ad09f0e675cf97a5944ab30d2.png"></p>
<h1 id="拾壹-defer语句——延时处理语句"><a href="#拾壹-defer语句——延时处理语句" class="headerlink" title="拾壹 defer语句——延时处理语句"></a>拾壹 defer语句——延时处理语句</h1><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行，通常该语句用来处理一些最后要执行的语句。</p>
<p>举个例子：</p>
<pre><code class="go">func main() &#123;
    fmt.Println(&quot;start&quot;)
    defer fmt.Println(1)
    defer fmt.Println(2)
    defer fmt.Println(3)
    fmt.Println(&quot;end&quot;)
&#125;
</code></pre>
<p><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/0ce07c6bfa643d88651940e35c7069dd.png" alt="0ce07c6bfa643d88651940e35c7069dd.png"></p>
<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<blockquote>
<p><strong>defer执行时机：</strong><br>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<br><img src="/images/Go%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/c40a9cf48aa7f33a10bcc8ffd23532eb.png" alt="c40a9cf48aa7f33a10bcc8ffd23532eb.png"></p>
</blockquote>
<p>在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p>
<p>如下示例</p>
<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) &#123;
src, err := os.Open(srcName)
if err != nil &#123;
return
&#125;
defer src.Close()

dst, err := os.Create(dstName)
if err != nil &#123;
return
&#125;
defer dst.Close()

return io.Copy(dst, src)
&#125;
</code></pre>
<p>以下是defer三条使用规则：</p>
<ul>
<li>当defer被声明时，其参数就会被实时解析<br>即defer的参数的变量值，在代码中defer使用后的位置改变并不会对改变defer用到的值</li>
<li>defer执行顺序为先进后出<br>在函数中，先定义的defer将会在最后执行</li>
<li>defer可以读取函数内变量<br>defer代码块的作用域仍然在函数之内，因此defer仍然可以读取函数内的变量</li>
</ul>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 小C♥天天
            <span class="footer-icon">
                <i class="fa-brands fa-github fa-fw"></i>
            </span>
            @小C&天天
        </div>
        <div>
            备案号：小C&天天の窝
        </div>
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        <!-- 2D模型 -->
        <div id="L2dCanvas" style="position: relative;"></div>
        <script src="/js/live2d.min.js"></script>
        <script src="/css/live2d.css"></script>
        <script>
            var v = new Viewer({
                basePath: "/model",
                role: "zhala_2",
                mobile: true,
            });
        </script>
        

        <!-- 点击 -->
        <script>
            let body = document.getElementsByTagName('body')[0];
            body.addEventListener('click', (e) => {
                let contentArr = ['✊','😘','😍','😊','😭','😡','😋','👍','🐷','😱','💷','💵','×','🆗','№','⭐','🌙','♥','💴','☀','🐎','🐂','🐏','√'];
                let randomNum = function (n) {
                    return Math.floor(Math.random() * n)
                }
                let span = document.createElement('span');
                span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
                span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
                span.style.position = 'absolute';
                span.style.top = `${e.pageY}px`;
                span.style.left = `${e.pageX}px`;
                span.style.transition = 'all 1s ease';
                span.style.zIndex = 20000;
                body.appendChild(span)
                setTimeout(()=>{
                    span.style.top = span.offsetTop - 100 + 'px';
                    span.style.opacity = 0;
                    setTimeout(()=>{span.remove()},700)
                },0)
            })
        </script>
            <!-- 流星背景特效 -->
            <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas>
        <script src="/js/background.js"></script>
        <!-- 背景音乐 -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
        <script src="/js/APlayer.min.js"></script>
        <div id="aplayer" class="aplayer" data-id="3027446018" data-server="netease" data-type="playlist" data-autoplay="true" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
        <script src="/js/Meting.min.js"></script>
    </body>
</html>